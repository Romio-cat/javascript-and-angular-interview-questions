# javascript-and-angular-interview-questions

JavaScript and Angular Interview Questions &amp; Answers

## Содержание

| № | Questions |
|---- | ---------
| I| [Основы](#Основы) |
| 1| [Чистота функции](#чистота-функции) |
| 2| [Что такое императивное программирование](#что-такое-императивное-программирование) |
| 3| [Что такое декларативное программирование](#что-такое-декларативное-программирование) |
| 4| [Что такое функция высшего порядка](#что-такое-функция-высшего-порядка) |
| 5| [Функциональное программирование](#Функциональное-программирование) |
| 6| [Реактивное программирование](#Реактивное-программирование) |
| 7| [Методологии разработки](#Методологии-разработки) |
| 8| [ООП](#ООП) |
| 9| [SOLID](#SOLID) |
| II| [HTML](#HTML) |
| III| [CSS](#CSS) |
| IV| [JavaScript](#JavaScript) |
| 1| [Типы данных](#Типы-данных) |
| 2| [Область видимости](#область-видимости) |
| 3| [Lexical environment](#Lexical-environment) |
| 4| [Замыкание](#Замыкание) |
| 5| [Hoisting](#Hoisting) |
| 6| [Разница между function expression и function declaration](#Разница-между-function-expression-и-function-declaration) |
| 7| [Способы создать объект](#Способы-создать-объект) |
| 8| [this](#this) |
| 9| [Что такое цепочка прототипов](#Что-такое-цепочка-прототипов) |
| 10| [Разница между for in и for of](#Разница-между-for-in-и-for-of) |
| 11| [Разница между методами массива slice и splice](#Разница-между-методами-массива-slice-и-splice) |
| 12| [Разница между == и ===](#Разница-между-==-и-===) |
| 13| [Каррирование](#Каррирование) |
| 14| [Разница между let и var](#Разница-между-let-и-var) |
| 15| [Что такое временная мертвая зона](#Что-такое-временная-мертвая-зона) |
| 16| [Классы в es6](#Классы-в-es6) |
| 17| [Что такое деструктуризация](#Что-такое-деструктуризация) |
| 18| [Способы привязать контекста к функции](#Способы-привязать-контекста-к-функции) |
| 19| [Прототипное наследование](#Прототипное-наследование) |
| 20| [Функциональное наследование](#Функциональное-наследование) |
| 21| [Назначение super в классе](#Назначение-super-в-классе) |
| 22| [Разница между obj.\_\_proto__ и obj.Prototype](#Разница-между-obj.\_\_proto__-и-obj.Prototype) |
| V| [TypeScript](#TypeScript) |
| 1| [Суть TypeScript в разработке](#Суть-TypeScript-в-разработке)
| 2| [Какие есть типы данных](#Какие-есть-типы-данных)
| 3| [Что такое Interface и во что он компилируется](#Что-такое-Interface-и-во-что-он-компилируется)
| 4| [Что такое Enum и во что он компилируется](#Что-такое-Enum-и-во-что-он-компилируется)
| 5| [Что такое геттеры и сеттеры в TypeScript?](#Что-такое-геттеры-и-сеттеры-в-TypeScript?)
| 6| [Generics (Обощенные типы)](#Generics-(Обощенные-типы))
| 7| [Как сделать так, чтобы классы, объявленные в модуле, были бы доступны и за пределами этого модуля?](#Как-сделать-так,-чтобы-классы,-объявленные-в-модуле,-были-бы-доступны-и-за-пределами-этого-модуля?)
| 8| [Поддерживает ли TypeScript перегрузку функций?](#Поддерживает-ли-TypeScript-перегрузку-функций?)
| 9| [Как в TypeScript перегрузить конструктор класса?](#Как-в-TypeScript-перегрузить-конструктор-класса?)
| 10| [Разница между interface и type в TypeScript?](#Разница-между-interface-и-type-в-TypeScript?)
| 11| [Для чего нужен тип «Omit»?](#Для-чего-нужен-тип-«Omit»?)
| 12| [Для чего нужен тип «Record»?](#Для-чего-нужен-тип-«Record»?)
| 13| [Когда используется ключевое слово «unknown»?](#Когда-используется-ключевое-слово-«unknown»?)
| 14| [Разница между абстрактным классом и интерфейсом typescript](#Разница-между-абстрактным-классом-и-интерфейсом-typescript)
| 15| [Когда нужно использовать ключевое слово «declare»?](#Когда-нужно-использовать-ключевое-слово-«declare»?)
| 16| [Как сделать все свойства интерфейса необязательными?](#Как-сделать-все-свойства-интерфейса-необязательными?)
| 17| [Использовании декораторов свойств в TypeScript](#Использовании-декораторов-свойств-в-TypeScript)
| 18| [Что такое «.map» файл, как и зачем его использовать?](#Что-такое-«.map»-файл,-как-и-зачем-его-использовать?)
| VI| [Angular](#Angular) |
| 1| [Метаданные компонента и какие из них обязательные](#Метаданные-компонента-и-какие-из-них-обязательные)
| 2| [Хуки компонента](#Хуки-компонента)
| 3| [Как написать структурную директиву](#Как-написать-структурную-директиву)
| 4| [Разница между ViewChild и ContentChild](#Разница-между-ViewChild-и-ContentChild)
| 5| [ngContent, ngContainer, ngTemplate](#ngContent,-ngContainer,-ngTemplate)
| 6| [hostListener и hostBinding](#hostListener-и-hostBinding)
| 7| [change detection](#change-detection)
| 8| [dependency injection](#dependency-injection)
| 9| [Как заинжектить переменную](#Как-заинжектить-переменную)
| 10| [Разница между объявлениями сервиса в компоненте или модуле](#Разница-между-объявлениями-сервиса-в-компоненте-или-модуле)
| 11| [Виды форм](#Виды-форм)
| 12| [Что такое router-outlet](#Что-такое-router-outlet)
| 13| [Как создать дочерний маршрут](#Как-создать-дочерний-маршрут)
| 14| [Виды guard](#Виды-guard)
| 15| [Виды pipe](#Виды-pipe)
| 16| [Для чего испольуется zone.js](#Для-чего-испольуется-zone.js)
| 17| [Tasks в zone.js](#Tasks-в-zone.js)
| 18| [Как протестировать асинхронный код](#Как-протестировать-асинхронный-код)
| 19| [Любые способы передать данные между двумя компонентами, даже самые нелепые](#Любые-способы-передать-данные-между-двумя-компонентами,-даже-самые-нелепые)
| 20| [Разница между AOT, JIT](#Разница-между-AOT,-JIT)

## Основы

1. ### Чистота функции

***Чистая функция*** - это функция, которой присущи следующие характеристики:
- Принимает на вход аргументы
- При одних и тех же аргументах возвращает одни и те же значения
- Не меняет внешний контекст
- Не вызывает нечистые функции
- Не имеет побочных эффектов

##### Пример:

```javascript
function getWordCount(arr) {
  return arr.length;// этой функции присущи все вышеобозначенные характеристики
}
```   
***Нечистая функция*** - это функция, которой, соответственно, обозначенные выше характеристики не присущи.

К ***побочным эффектам*** функции относят вызовы API, манипулирование DOM-ом, запись в базу данных, чтение и модификация глобальных переменных.

2. ### Что такое императивное программирование
***Императивное программирование*** - это способ написания кода, в котором фокусом есть *описание логики* работы программы. К такому коду можно поставить вопрос **"Как именно мы что-то делаем?"**.
##### Пример:
Нужно написать функцию, которая принимает массив, а возвращает сумму значений массива. Императивным подходом это решается следующим образом:

```javascript
function add(arr) {
  let result = 0;
  for(let i = 0; i < arr.length; i++) {
    result += arr[i];
  }
  return result;
}
```
Как видно из примера - мы описали как именно мы достигаем решения поставленной задачи (сначала у нас результат 0, потом проходимся по массиву, потом возвращаем результат).

3. ### Что такое декларативное программирование
***Декларативное программирование*** - это способ написания кода, в котором фокусом есть *указание результата*, который мы хотим получить. К такому коду можно поставить вопрос **"Что именно мы получаем?"**
#### Пример:
Задача стоит такая же, как и в предыдущем пункте. Декларативным подходом это решается следующим образом:

```javascript
function add(arr) {
  return arr.reduce((prev, current) => prev + current, 0);
}
```

Как видно из примера - мы пишем ***ЧТО*** мы хотим получить, и не задумываемся, как именно оно получится. Но, понятное дело, что под этой декларативной записью скрывается что-то императивное, но оно скрыто.

Ссылка на статью, где приводятся аналогии с реальной жизнью: https://ui.dev/imperative-vs-declarative-programming/  

4. ### Что такое функция высшего порядка
***Функция высшего порядка*** - это функция, которая принимает на вход другие функции, или же возвращает другие функции.
#### Примеры:
```javascript
function sayHi() {
  alert('Hi!');
}

function greet(greeting) {
  greeting();
}

greet(sayHi);// передаём функцию sayHi в качестве аргумента функции greet.
```   
а также:

```javascript     
function whenMeetingJohn() {
  return function() {
    alert('Hi!);
  }
}

let atLunchToday = whenMeetingJohn();
atLauchToday();
```

5. ### Функциональное программирование
***Функциональное программирование*** - это одна из парадигм программирования, которая базируется на следующих принципах:

   - основные функции реализованы с **использованием чистых функций без побочных эффектов**
   - **данные не изменяются**
   - функциональные программы **не имеют состояния**
   - императивный код **контейнера (нечистая функция) управляет побочными эффектами и выполняет декларативный**, чистый код ядра.

#### Пример:

```javascript        
const fpCopy = `Functional programming is powerful and enjoyable to write. It's very cool!`;

// все функции, кроме последней - чистые. Не изменяют никакие данные.
const stripPunctuation = (str) => str.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, '');

const getArr = (str) => str.split(' ');

const getWordCount = (arr) => arr.length;

const getKeywords = (arr) => arr
  .filter(item => item.length > 5)
  .map(item => item.toLowerCase());

// это контейнер, который является нечистой функцией. Управляет побочными эффектами и выполняет предыдущие чистые функции
function processCopy(str, prepFn, arrFn, countFn, kwFn) {
  const copyArray = arrFn(prepFn(str));
  return `Word count: ${countFn(copyArray)}, keywords: ${kwFn(copyArray)}`;
}

processCopy(fpCopy, stripPunctuation, getArr, getWordCount, getKeywords);
```   

6. ### Реактивное программирование
***Реактивное программирование*** - это парадигма программирования, которая заключается в декларативным наблюдении и реагировании на поступающие события во времени.  

7. ### Методологии разработки
 - Agile
   * экстремальное программирование (Extreme Programming, XP); <br>
   ***Цель*** - справиться с постоянно меняющимися требованиями к программному продукту и повысить качество разработки. 4 принципа:<br>
     1) **Кодирование** согласно единым в команде стандартам оформления.
     2) **Тестирование**. Тесты пишут сами программисты ещё до написания кода, который будут тестировать.
     3) **Планирование**. И финальное и отдельных итераций. (В среднем раз в две недели)
     4) **Слушание**. И разработчиков, и клиента. Цель - устранить неясности и недопонимания, определить четкие требования и ценности.

   * бережливая разработка программного обеспечения (Lean); <br>
   ***Цель*** - повышение эффективности процесса разработки, минимизация затрат.<br>
     1) **Избавление от потерь** (плюс к качеству). Если что-то не нужно, то его лучше убрать.
     2) **Постоянное обучение команды (плюс к эффективности)**
     3) **Принятие решения так поздно, как только можно.** Решения должны быть продуманными и взвешенными. (плюс к эффективности и качеству)
     4) **Быстрая доставка**
     5) **Усиление команды.** “Люди и взаимодействие важнее процессов и инструментов”. То, как люди в команде могут взаимодействовать и кооперироваться - важнее даже того, какие инструменты они используют. (плюс к эффективности)
     6) **Целостность и качество.** Изначально нужно делать качественный продукт, то есть не избавляться от проблем и багов, а пресечь их появление (плюс и к эффективности, и к качеству). + **Видение цельной картины.** Нужно чётко понимать, какой текущий статус разработки, какие цели, концепции и стратегии у разрабатываемого ПО
   * фреймворк для управления проектами Scrum;<br>
   ***Scrum*** - методология управления проектами, сутью котого есть постоянная вовлеченность в процесс разработки кроме специалистов ещё и владельца продукта (человек, который соединяет команду с заказчиком, мониторит развитие проекта) + scrum-master (человек, который проводит совещания, мотивирует команду, мониторит соблюдение самого scrum). По Scrum рабочий процесс делится на спринты (некоторые промежутки времени, от недель до месяца). Каждый раз перед началом нового спринта формулируются цели и задачи, которые нужно достичь/решить, в конце каждого спринта обсуждаются результаты, успехи либо фейлы. Что удобно - можно сравнивать эти самые спринты, оценивать эффективной работы, ею управлять.   
   * разработку, управляемую функциональностью (Feature-driven development, FDD);
   * разработку через тестирование (Test-driven development, TDD); <br>
   Методология разработки ПО, которое основывается на повторении коротких циклов разработки:
     1) Пишется тест, который покрывает нужные изменения;
     2) Пишется код, который желаемые изменения, собственно, реализует и позволяет пройти тест.
     3) Проводится рефакторинг написанного кода.

   * методология «чистой комнаты» (Cleanroom Software Engineering); <br>
     Процесс разработки программного обеспечения, который предназначен для создания ПО с сертифицируемым уровнем надежности. Основной принцип: предупреждение проблем (дефектов) лучше, чем их устранение. <br>
     Основан на следующем:
     1) Разработка ПО основывается на формальных методах;
     2) Инкрементальная реализация в рамках статистического контроля качества.
     3) статистическое тестирование;
     4) формальная верификация.

   * итеративно-инкрементальный метод разработки (OpenUP); <br>
   Метод разработки, который делит цикл проекта на четыре фазы:
     1) Начальная фаза
     2) Фаза уточнения
     3) Фаза конструирования
     4) Фаза передачи.

   * методологию разработки Microsoft Solutions Framework (MSF); <br>
   Методология, которая базируется на 8 принципах:
     1) Cвободный и открытый обмен инфой между участников внутри команды и заинтересованными сторонами. (снижает вероятность недопонимания и переделывания работы)
     2) Общий взгляд участников команды на результат, понимание в равной степени всеми целей и задач, над которыми ведётся работа.
     3) Каждый участник обладает максимально полными полномочиями, которые нужны для выполнения задачи.
     4) Разделение ответственности. Все успехи и неудачи команды делятся поровну.
     5) Ориентировка на клиента, на его потребности.
     6) Готовность к переменам требований, условий.
     7) Раннее выявление ошибок и недочетов, которое реализуется на протяжении всего проекта.
     8) Развитие сотрудников, обмен информацией и опытом.

   * метод разработки динамических систем (Dynamic Systems Development Method, DSDM); <br>
   Метод разработки, который основан на концепции быстрой разработки приложений.
   9 принципов DSDM: <br>
     1) Вовлечение пользователя. Для более точного принятия решения разработчики делят с пользователями рабочее пространство.
     2) Необходимость, чтобы команда могла самостоятельно принимать решения (без предварительного согласования с начальством)
     3) Принцип "лучше сделать раньше, но просто хорошо, чем отлично, но в самом конце"
     4) Быстрая доставка ПО, которое удовлетворяет текущим потребностям рынка.
     5) Итеративная (т.е такая, которая происходит с непрерывным анализом полученных результатов и коректировкой предыдущей работы) и инкреметная разработка
     6) любые изменения во время разработки обратимы.
     7) требования формулируются на высоком уровне прежде, чем начнётся проект.
     8) в жизненный цикл разработки обязательно интегрируется тестирование.
     9) крайне необходимо взаимодействие и сотрудничество между всеми учасниками (плюс к эффективности)

   * метод управления разработкой Kanban. <br>
   Kanban держится на 4 столбах: <br>
     1) "Карточки". Для каждой задачи - отдельная карточка, где записана вся необходиммая инфа.
     2) Ограниченное количество задач на одном этапе.
     3) Непрерывный поток.
     4) Постоянное улучшение и совершенствование. То есть постоянный и непрерывный анализ производственного процесса + поиск путей дял повышения производительности.

 - ***Waterfall*** (или же каскадная модель) - модель процесса разработки, которая делит создание проекта на несколько частей (а именно анализ требований, проектирование, реализация, тестирование, интеграция и поддержка), которые следуют один за другим (как поток). Суть в том, что один этап разработки **не может начаться**, пока не завершится другой. Основные принципы - **строгая последоватеьность** и **однократное выполнение** каждоого этапа.

 - ***Спиральная модель*** - модель разработки ПО, которая сочетает идеи итеративной и каскадной моделей. Создание проекта также делится на этапы, но (поскольку у нас спиральная модель) эти этапы повторяются на каждом новом "витке". Просто на выходе с каждого "витка" мы получаем протестированный "прототип", который дополняет существующий билд и дальше начинаются те же этапы и т.д, до тех пор, пока не получим прототип, который удовлетворяет всем требованиям.
8. ### ООП
***ООП*** - парадигма программирования, в которой основными концепциями являются понятия объектов и классов.<br>
Базовыми принципами ООП есть следующие:
- **Абстрагирование**. Означает, что нужно выделить некий набор характеристик объекта. Характеристики должны быть значимыми. **Абстракция**, в свою очередь - это набор значимых характеристих объекта.
- **Инкапсуляция**. То, что помогает "защитить" жизненно важные данные для компонента, а также скрыть детали реализации от пользователя. Но последний, в свою очередь, может взаимодействовать с компнентом при помощи некоего интерфейса.
- **Наследование**. Способность объекта или класса базироваться на другом объекте или классе, способность одного объекта приобретать свойства другого, добавлять к ним что-то, что характерно только для него. Через наследование чётко видна их иерархия.
- **Полиморфизм**. Реализация одной и той же задачи разными способами.<br><br>
  Также используются правило **DRY (Don't repeat yourself)**, то есть правило того, что каждая инфа, кадый кусочек кода должен быть представлен в единственном числе в одном месте программмы + принципы **SOLID**.
9. ### SOLID
***SOLID*** - это набор из 5 принципов (сам термин - это акроним из названий этих принципов), который помогает делать код как-будто действительно очень устойчивым и крепким (а слово "solid" с англ так и переводится), читай хорошо организованным, понятным и поддерживаемым, там, где уж точно какое-то изменение в дальнейшем не будет иметь результатом полный крах всего :).<br>
Итак, эти принципы:
- **Single Responsibility Principle (принцип персональной ответственности)**<br>
   Класс должен иметь лишь одну ответственность, то есть должен отвечать только за одну вещь, на него возложена одна единственная обязанность. Другими словами, Do one thing and do it well!
- **Open/Closed Principle (Принцип открытости/закрытости)**<br>
   Программные сущности должны быть открыты для расширения, но закрыты для изменения.
   Иными словами, следует создавать классы таким образом, чтобы со временем можно было дополнить их функционал, но при этом не нужно было затрагивать старый код. Эффективно и быстрее писать новое, расширять уже существующее, при этом не пересматривая и не переделывая уже написанное.
- **Liskov Substitution Principle**<br>
   Объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.
- **Interface Segregation Principle**<br>
   Клиенты не должны зависеть от методов, которые они не используют.
- **Dependency Inversion Principle**<br>
   Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

   3 статьи, где объясняются эти 5 принципов:

    * https://webdevblog.ru/solid-principy-chast-1/ (1 и 2 принципы).
    * https://webdevblog.ru/solid-principy-chast-2/ (3 принцип).
    * https://webdevblog.ru/solid-principy-chast-3/ (4 и 5 принцип).


## HTML
## CSS
## JavaScript

1. ### Типы данных

В JavaScript существуют следующие типы данных:
  - ***Примитивные типы данных (примитивы):***
    * **Number**

       Кроме чисел в привычном понимании этого слова, к этому типу данных относятся ещё `Infinity`, `-Infinity` и `NaN`.
       Обычные числа хранятся в 64-битном формате IEEE-754 (числа с плавающей запятой двойной точности): 52 из них используются для хранения цифр,
       11 - для положения десятичной точки, 1 - для знака. Диапазон: от -2^53 до 2^53. Для чисел, которые больше этого, используется другой тип данных BigInt.
    * **BigInt**

       Для создания bigInt нужно добавить в конец целочисленного литерала `n`. Например: `10n`, `9007199254740991n`
    * **String**

       Для создания строки используются одинарные, двойные или обратные кавычки. Формат - UTF-16
    * **Boolean**

       Тип данных, который принимает только 2 значения: `true` и `false`.
    * **Null**

       Тип данных, который содержит только значение `null`. Это значение представляет собой "ничего", "пусто" или "значение неизвестно".
    * **Undefined**  

       Тип данных, который содержит только значение `undefined`. Это значение означает, что "значение неприсвоено".
    * **Symbol**

       Символ - это уникальный идентификатор. Использутся в качестве ключа для свойства объекта. Позволяют создавать "скрытые" свойства объектов, к которым нельзя нечаянно обратиться и перезаписать из других частей программы.
  - ***Непримитивные***:
    * **Object**

       Объект - тип данных, который используется для хранения множества значений и сложный сущностей. Объект состоит из полей, каждый из которых является парой *ключ - значение*. Объекты таже называют "ссылочным типом".

Разница между примитивамы и непримитивами (объектами) в том, что:
   - примитивные типы данных содержат только одно значение, в то время как объект - это набор из множества данных.
   - примитивные типы данных не изменяемы, а объекты изменяемы.
   - примитивы сравниваются по значению, то есть примитивы будут строго равны, если они имеют одно значение. Объекты не сравниваются по значению. Даже если
   два объекта имеют одинаковые ключи и значения, то они не будут строго равны.

2. ### Область видимости
***Область видимости (Scope)*** можно определить как некий механизм, который собирает и обслуживает список поиска всех объявленных переменных. Область видимости делится на 2 категории: **лексическая** (другое, и более понятное, название **статическая**) область видимости и **динамическая** область видимости. Отличие первой от второй в том, что при первой "границы" области видимости устанавливаются во время объявления функции (другими словами во время компиляции, т.е первого прохода интерпретатора по коду), а не во время выполнения. То есть, неважно где функция была вызвана, важно то, где она была объявлена. В JS используется первый тип области видимости.   
#### Например:
```javascript
let a = 5;

function myFunc() {
  return a;
}

function myFunc2() {
  let a = 10;
  return myFunc();
}

myFunc2();// 5
```   
В этом примере результатом будет 5, потому что функция myFunc "видит" только a = 5. Это "видение" закрепилось во время объявления функции.  
Также область видимости можно поделить на:
   - **глобальную область видимости** (доступна всем)
   - **функциональную область видимости** (всё, что находится в пределах функции "видно" только внутри функции)
   - **блочную область видимости** (ограничена блоком кода).  
3. ### Lexical environment  

***Лексическое окружение*** - это связь сущности с контекстами её породившими (контекст выполнения, к слову, это некая концепция, которая описывает окружение в котором производится выполнение кода. Каждый контекст помещается в стек вызовов, потом удаляется). Технически, лексическое окружение является **объектом**, который имеет два свойства: *запись окружения* (в котором хранятся объявления) и *ссылку на лексическое окружение порождающего контекста*.  
Например:  
```
myFuncLexicalEnvironment = {
  environmentRecord: {
    someVariable : 5,
    someFunction: < somefunction function reference>
  }
  outer: <globalLexicalEnvironment>
}
```
Это лексическое окружение образуется во время вызова следующей функции:
```javascript
function myFunc() {
  let someVariable = 5;

  return function someFunction() {
    return someVariable;
  };
}

let f = myFunc();
```
Лексическое окружение создаётся на этапе создания контекста (например, вызова функции, выполнения блока кода *if*) и помещение его в стек вызовов. Поиск переменных через лексическое окружение схож по принципу работы на область видимости, но лексическое окружение нужно ещё для одной важной вещи: при удалении контекста выполнения из стека, его лексическое окружение "живёт" до тех пор, пока есть ссылка на него (например, есть хотя бы одна вложення функция, которая ссылается на него).  

4. ### Замыкание
***Замыкание*** - это функция, которая запоминает свои внешние переменные и может получить к ним доступ. В JS функции изначально являются замыканиями. Замыкания возможны благодаря лексическому окружению, которое было рассмотрено в предыдущем пункте.  

5. ### Hoisting  
***Hoisting*** (*поднятие*, *всплытие*) - это механизм в JS, в котором объявления переменных (объявленных через `var`; объявленные через `let` тоже всплывают, но у них есть особенность, о которой ниже) и объявления функций (т.е *function declaration*) передвигаются вверх по своей области видимости. Таким образом, мы можем вызывать функции, объявленные через *function declaration* до их объявления. И обращаться к переменным, объявленным через `var` до их объявления.
```javascript
myFunc();//'Hello!', объявление функции "всплыло" и она теперь как бы находится перед вызовом

function myFunc() {
  return 'Hello!';
}
```
```javascript
console.log(a);//undefined, всплыло только объявление

var a = 5;
```
Интересные примеры:
```javascript
var test = 6;

function test() {}

console.log(typeof test);//number
```
а тут:
```javascript
var test;

function test() {}

console.log(typeof test);//function
```

6. ### Разница между function expression и function declaration

Основное различие между ними в том, что функции, объявленные как *Function Declaration*, создаются интерпретатором до выполнения кода (связано с всплытием), а функции, объявленные при помощи Function Expression, создвются во время выполнения выражения. Поэтому их можно вызывать до объявления функции:
```javascript
sayHi("Veronica");//Hello, Veronica

function sayHi(name) {
  return(`Hello, ${name}`);
}
```
С Function Expression такого не будет:
```javascript
sayHi('Veronica');//будет ошибка

let sayHi = function(name) {
  return(`Hello, ${name}`);
}
```
7. ### Способы создать объект

Существует 3 способа создать объект:  
  - Через литерал объекта:

```javascript
let obj = {};
```
  - Через функцию-конструктор:

```javascript
function myFunc() {}

let obj = new myFunc();
```

  - Через Object.create():

```javascript
let obj = Object.create(obj2);//но здесь obj2 мы устанавливаем как прототип для obj
```
8. ### this
- Значение this в глобальном контексте зависит от того, используется ли `use strict` или нет. В `use strict` значение `this === undefined`, в нестрогом - `this === window` (это в браузерах).
- `this` внутри функции ссылается на внешний контекст:

```javascript
function myFunc() {
  'use strict'
  return this;
}

myFunc();//undefined, потому что используется 'use scrict'
```
  - В контексте объекта (и в методах) `this` ссылается на этот объект:

```javascript
let obj = {
  objProperty: "propertyValue",
  objMethod() {
    return this.objProperty;
  }
}

var objProperty = "this is a global window property";//var здесь и далее используется для наглядности

obj.objMethod();//propertyValue
obj.objMethod.call(window);//this is a global window property
```

  - Используя методы call() и apply(), можно вызывать функцию в нужном контексте:

```javascript
function myFunc() {
  return this.a + this.b;
}

let obj = {
  a: 1,
  b: 2,
}

var a = 6;
var b = 10;

myFunc();//16
myFunc.call(obj);//3
```

  - При помощи bind() можно создать новую функцию на основе имеющейся и привязать ей нужный контекст:

```javascript
function a() {
  return this.b;
}

let obj = {b: "objb"};
var b = "globalb";
let func = a.bind(obj);

a();//globalb
func();//objb
```

  - У стрелочных функций нет своего `this`. Значение берётся снаружи:

```javascript
let obj = {
  name: 'obj',
  letters: ['a', 'b', 'c'],

  showLetters() {
    this.letters.forEach(item => `${this.name}: ${item}`);
  }
};

obj.showLeters();//obj: a, obj: b, obj: c
```
  - Если использовать функцию как обработчик события, то `this` присваивается элементу, с которого начинается событие
  - В инлайновом обработчике, `this` указывает на DOM элемент, в котором расположен код события.

9. ### Что такое цепочка прототипов
***Цепочка прототипов*** - это некий механизм, которые позволяет одним объектам использовать свойтсва и методы, которые определены в других объектах, которые являются для первых прототипами.  
В JS вообще каждый объект имеет объект-прототип, который выступает как шаблон, от которого объект наследует методы и свойства. Реализуется это при помощи цепочки прототипов.  

Пример:

 ```javascript
let obj1 = {
  name: "obj1",
  isAlive: true,
};

let obj2 = {
  name: "obj2",
  isHappy: true
};

let obj3 = {
  name: "obj3",
};

//создаём цепочку:
obj2.__proto__ = obj1;
obj3.__proto__ = obj2;

//Проверяем:
console.log(obj3.__proto__.__proto__);//будет obj1

//но также:
console.log(obj3.__proto__.__proto__.__proto__);//Object {}

//конец цепочки:
console.log(obj3.__proto__.__proto__.__proto__.__proto__)//null

//проверяем доступ к свойствам прототипов:
console.log(obj3.isHappy);//true, такого свойства нет у obj3, но есть у его прототипа
console.log(obj3.isAlive);//true, такого свойства нет у obj3, но есть у прототипа его прототипа
 ```

10. ### Разница между for in и for of
- `for...of` вызывает на каждом шаге итерации **значение**, а не ключ. `for...in` вызывает на каждом шаге итерации **ключ**, а не значение.
- `for...of` работает с перебираемыми объектами.
11. ### Разница между методами массива slice и splice  

- Метод `slice` имеет синтаксис `arr.slice([start], [end])` и предназначен для **копирования элементов из массива `arr`**. Возвращает **новый** массив скопированных элементов (начиная со `start` и заканчивая `end` не включая). **Копирование** подразумевает, что **исходный массив не изменяется**:

```javascript
let arr = [1, 2, 3, 4, 5];
let newArr = arr.slice(0, 3);

console.log(arr);//[1, 2, 3, 4, 5], исходный массив остался прежним
console.log(newArr);//[1, 2, 3]
```

- Метод `splice` имеет синтаксис `arr.splice(index [, deleteCount, elem1, ..., elemN])` и предназначен для **удаления из массива `arr` `deleteCount` элементов, начиная с `index`**, а также вставки элементов `elem1` и т.д на их место. Возвращает массив удалённых элементов. **Удаление** подразумевает, что **исходный массив меняется**:

```javascript
let arr = [1, 2, 3, 4, 5];
let newArr = arr.splice(0, 3);

console.log(arr);//[4, 5], исходный массив изменился!
console.log(newArr);//[1, 2, 3]
```
12. ### Разница между == и ===

Разница между `==` ("нестрогое равенство", "абстрактное равенство") и `===` ("строгое равенство", "идентичность") в том, что `==` перед сравнением выполнит приведение типов, а `===` этого не делает:

```javascript
let a = 5;
let b = '5';

console.log(a == b);//true
console.log(a === b);//false
```
13. ### Каррирование
***Каррирование*** - одна из продвинутых техник для работы с функциями. Суть - в трансформации функции таким образом, чтобы они принимали аргументы не как f(a, b), а как f(a)(b):
```javascript
function curry(f) {
  return function(a) {
    return function(b) {
      return f(a, b);
    }
  }
}

function multiply(a, b) {
  return a * b;
}

let curriedMultiply = curry(multiply);
curriedMultiply(4)(5);//20
```
Можно применять, например, чтобы зафиксировать аргумент. Например, в коде выше можем создать функцию, вызывая которую, будем умножать какое-то фиксированное число на другое:
```javascript
//добавляем в код выше следующее:
let multiplyByFour = curriedMultiply(4);//фиксируем аргумент

multiplyByFour(5);//20
multiplyByFour(10);//40
```  
14. ### Разница между let и var  

Различия `var` и `let` в том, что:
   - У переменных `var` нет блочной области видимости. Они ограничиваются только телом функции (если объявлены в ней); `let` же "закрываются" в том блоке кода, в котором объявлены.

   Например, когда мы используем `var`:

```javascript
if (true) {
  var test = 5;
}

console.log(test);//5
```
   Но в то же время если использовать `let`:
```javascript
if (true) {
  let test = 5;
}

console.log(test);//ReferenceError: test is not defined
```
   - Объявление (но не присваивание!) `var` производится в начале исполнения функции или скрипта. Иными словами, объявление `var` всплывает. `let` тоже всплывает, но из-за ***мёртвой временной зоны*** (о ней ниже) мы не можем к ним обратиться раньше времени.

   Например, c `var`:

```javascript
function myFunc() {
  console.log(test);

  var test = 6;
}

myFunc();//undefined
```

   А с `let` будет следующее:
```javascript
function muFunc() {
  console.log(test);

  let test = 6;
}

myFunc();//ReferenceError: test is not defined
```
   - В браузере переменные, объявленные с помощью `var` становятся свойствами глобального объекта (поведение поддерживается для совместимости). У `let` такого поведения нет.
   Пример:

```javascript
var globalVar = 6;

console.log(window.globalVar);//6
```
   Но:
```javascript
let globalVar = 6;

console.log(window.globalVar);//undefined, такого свойства нет.
```
15. ### Что такое временная мертвая зона

***Временная мёртвая зона*** - это явление, которое блокирует доступ к поднятой переменной, объявленной через `let`, во избежание путаницы. Следующий код это наглядно демонстрирует:

```javascript
let x = 'outer value';

(function() {
  console.log(x);//Uncaught ReferenceError: Cannot access 'x' before initialization
  let x = 'inner value';
}());

```
Если бы `let` действительно не поднимались, то мы бы получили в результате 'outer value'. А из-за *временной мёртвой зоны* мы просто не можем обратиться к поднятой переменной, которую мы объявили в IIFE.

16. ### Классы в es6
***Классы в ES6*** - это более продвинутая конструкция, чем функции-конструкторы, своеобразная "надстройка":
```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }

  sleep(hours) {
    return(`${this.name} спит ${hours} часов`);
  }
}

let koala = new Animal("Коала");

koala.sleep(20);//Коала спит 20 часов

console.log(Animal === Animal.prototype.constructor);//true
console.log(Object.getOwnPropertyNames(Animal.prototype));//constructor, sleep
```
Используя же обычные функции-конструкторы код можно переписать следующим образом:
```javascript
function Animal(name) {
  this.name = name;
}

Animal.prototype.sleep = function(hours) {
  return(`${this.name} спит ${hours} часов`);
}

let koala = new Animal("Коала");
koala.sleep(20);//Коала спит 20 часов
```
Но всё же классы - это не совсем "синтаксический сахар" (т.е синтаксис для улучшения читаемости кода, но не делающий ничего принципиально нового). Есть несколько различий:
- Мы не можем вызвать класс без использования `new`, а функции можем.
- Методы класса - неперечисляемы. Определение класса устанавливает `false` для флага `enumerable` для всех методов, которые находятся в `prototype`.
- Весь код внутри классов автоматически находится в строгом режиме.  
17. ### Что такое деструктуризация
***Деструктуризация*** - это особый синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным, разбив его на части. Пример с массивом:
```javascript
'use strict';

let [firstName, lastName] = ["Имя", "Фамилия"];

console.log(firstName);
console.log(lastName);
```
Пример с объектом:
```javascript
'use strict';

let menu = {
  firstMeal: "soup",
  secondMeal: "pasta",
  beverage: "tea"
};

let {myFirstMeal, mySecondMeal, myBeverage} = menu;

console.log(myFirstMeal);//soup
console.log(mySecondMeal);//pasta
console.log(myBeverage);//tea
```
И если посложнее:
```javascript
let menu = {
  title: "Our Menu",
  sections: {
    firstMeals: ["soup", "borshsch"],
    secondMeals: ["pasta", "mashed potatoes"],
    beverages: ["tea", "coffee", "cola"],
  }
};

let {
  sections: {
    firstMeals,
    secondMeals,
    beverages,
  },
  pages = 20//в объекте menu такого нет
} = menu;

console.log(pages);//20
console.log(firstMeals);//["soup", "borshsch"]
console.log(secondMeals);//["pasta", "mashed potatoes"]
console.log(beverages);//["tea", "coffee", "cola"]
```
18. ### Способы привязать контекста к функции

- использовать bind:

```javascript
let obj = {
  firstValue: 5,
  secondValue: 6,
};

function add() {
  return this.firstValue + this.secondValue;
}

let addObjValues = add.bind(obj);

addObjValues();//11
```
- также для привязки контекста к функции подходят `call` и `apply`, но они используются для непосредственно вызова функции в том или ином контексте.

Пример с `call`:

```javascript
let student = {
  firstName: "John",
  lastName: "Miller",
};

function getFullName(firstName, lastName) {
  return `Full name: ${this.firstName} ${this.lastName}`;
}

getFullName.call(student, "firstName", "lastName");//Full name: John Miller
```
Пример с `apply`:

```javascript
let student = {
  firstName: "John",
  lastName: "Miller",
};

function getFullName(firstName, lastName) {
  return `Full name: ${this.firstName} ${this.lastName}`;
}

console.log(getFullName.apply(student, ["firstName", "lastName"]));//Full name: John Miller
```

19. ### Прототипное наследование
***Прототипное наследование*** - механизм в программировании, с помощью которого можно, за неимением в объекте собственного свойства или метода, найти их в объекте, который для этого объекта является прототипом. Если и в этом объекте этого свойства или метода нет, то найти в объекте, который для этого объекта является прототипом, и т.д.  

Пример прототипного наследования был дан в ответе на вопрос о [цепочке прототипов](#Что-такое-цепочка-прототипов)

20. ### Функциональное наследование  
***Функциональное наследование*** (*функциональный паттерн наследования*) - это такая организация наследования, при которой:
  - Родитель объявляется через функцию конструктор. У родителя могут быть приватные, публичные и защищённые свойства.
  - Для реализации наследования конструктор потомка вызывает родителя в своём контексте через `apply`/`call`. После этого может добавить свои переменные и методы.
  - Для расширения метода родителя этот метод копируется в переменную.  
 К слову, функциональное наследование применяется нечасто. Прототипный подход намного более используемый и обладает рядом преимуществ, также более понятен.  

Пример:
```javascript
function Machine() {
  let enabled = false;

  this.enable = function() {
    enabled = true;
  };

  this.disable = function() {
    enabled = false;
  };
}

function WashingMachine() {
  Machine.call(this);//реализуем наследование

  let powderAmountInMl = 0;

  this.setPowderAmountInMl = function(amountInMl) {
    powderAmountInMl = amountInMl;
  };
}

let washingMachine = new WashingMachine();

washingMachine.enable();//нам доступны методы родителя
washingMachine.disable();
washingMachine.setPowderAmountInMl(250);//также есть свои методы
```

21. ### Назначение super в классе

Ключевое слово ***super*** нужно для двух случаев:
- вызвать родительский метод (`super.method(...)`)
- вызвать родительский конструктор (`super(...)`)

22. ### Разница между obj.\_\_proto__ и obj.Prototype  

Через obj.\_\_proto__ мы можем получить объект, который является прототипом для этого объекта. В каждом объекте есть скрытое поле [[Prototype]], в котором хранится ссылка на прототип. Поскольку это поле скрыто и мы не может его получить напрямую, то используем obj.\_\_proto__.  
obj.prototype - это свойство функции-конструктора (в данном случае функции obj), в котором хранится объект, имеющий одно свойство constructor. Во время создания объектов при помощи функции-конструктора делается следующее: записывается в поле [[Prototype]] создаваемого объекта ссылка на объект, который хранится в obj.prototype. В этот же объект, к слову, записываются и все методы, которые будут наследоваться новосозданными при помощи функции-конструктора объектами.

```javascript
function Animal(name) {
  this.name = name;
}

Animal.prototype.sleep = function(hours) {
  return `${this.name} спит ${hours} часов в сутки`;
};

let koala = new Animal('Koala');

console.log(koala.__proto__ === Animal.prototype);//true
```

## TypeScript

1. ### Суть TypeScript в разработке
- Предотвращает появление множества багов. Следующий пример это хорошо демонстрирует:

```javascript
function getHumanReadableMessage(response) {
  if (response.data.hasSucceeded) {
    return `Your action succeeded because: ${response.message}`;
  }

  return `Something went wrong:(`;
}

const apiResponse = {
  data: {
    hasSucceeded: true,
    message: `Successful log in.`,
  },
};

console.log(getHumanReadableResponse(apiResponse));//Your action succeeded because: undefined
```
То есть, в приведённом выше примере не будет даже ошибки при выполнении, потому что в JS мы можем обращаться к
несуществующим свойствам объекта. Но это ведь не то, что нужно.

А вот если использовать TS:
```typescript
interface ApiResponse {
  data: {
    hasSucceeded: boolean;
    message: string;
  };
}

function getHumanReadableResponse(response: ApiResponse) {
  if (response.data.hasSucceeded) {
    return `Your action succeeded because: ${response.message}`;//ещё до компиляции получим ошибку, что свойство 'message' doesn't exist in type ApiResponse
  }

  return `Something went wrong:(`;
}

const apiResponse = {
  data: {
    hasSucceeded: true,
    message: `Successful log in.`,
  },
};

getHumanReadableResponse(apiResponse);
```
- Очевидно, что в связи с предыдущим пунктом значительно сокращается время разработки, так как не тратится время на выявление таких ошибок
- Строгая типизация избавляет от ручной проверки, например, типов аргументов в функции.
- Лучшая читаемость, поддерживаемость.

2. ### Какие есть типы данных  

В TS существуют следующие базовые типы данных (для тех, которые соотносятся с типами в JS, примеры не приводятся):
- `Boolean`
- `Number`
- `BigInt`
- `String`
- `Array`

Создать массив можно так:

```typescript
let list: number[] = [1, 2, 3, 4, 5];
```
А можно так (используя т.н *дженерик-тип*):

```typescript
let list: Array<number> = [1, 2, 3, 4, 5];
```

- `Tuple` (Кортежи)

Похожи на массивы, но имеют важную особенность: указывают на тип каждого элемента.
Очевидно, что кроме типов в создаваемом кортеже должно совпадать также количество
позиций.

```typescript
let tupleExample: [number, string, boolean] = [42, "tuple", true];
```

- `Enum` (Перечисление)

Перечисление позволяет определять именованые константы. Можно создавать текстовые и числовые, смешанные.

```typescript
enum Direction {
  Up,
  Down,
  Left,
  Right
}
```

[Подробнее в ответе на вопрос 4](#Что-такое-Enum-и-во-что-он-компилируется).

- `Unknown`

Тип используется, когда переменной может быть присвоено значение любого типа. Однако, хотя
всё что угодно может быть присвоено `unknown`, но `unknown` не может быть присвоен ничему:

```typescript
let varUnknown: unknown = 20;

let str: string = varUnknown;//Type 'unknown' is not assignable to type 'string'
```

- `Any`

Тип, похожий на `unknown`, но имеет отличие: переменную с таким типом можно присваивать другим типам.
Можно даже попытаться прочитать свойство, которое даже не существует (такого с `unknown` не сделаешь):

```typescript
let varAny: any = 20;
let str: string = varAny;//ошибки не будет, всё ок.

varAny.method();//по-прежнему никакой ошибки
```

- `Void`

Буквально означает отсутсвие какого-либо типа. В основном используется в функциях, которые не возвращают никакого значения:

```typescript
function warnUser(): void {
  console.log("This is my warning message");
}
```
Также используется как тип переменной со значением `undefined`:

```typescript
const x: void = undefined;
```

- `Null` и `Undefined`
Принимают соответствующие значения null и undefined. Но фактически мы можем присваивать значения
`null` и `undefined` переменным других типов.
- `Never`
Представляет отсутствие значения и используется в качестве возвращаемого типа функций, которые генерируют или возвращают ошибку.
- `Object`

3. ### Что такое Interface и во что он компилируется
***Interface (Интерфейс)*** можно определить как некоторую договорённость, контракт, которому должны следовать сущности в коде.
Этот "контракт" устанавливает, ***что*** должно быть сделано, но не ***как***. При этом хоть и обязательно, чтобы сущности следовали установленным
договорённостям, однако они могут добавлять и свои.
Интерфейсы можно использовать, чтобы определить структуру функций:
```typescript
interface Order {
  (customerId: number, modelId: number): boolean
}

let orderFn: Order = function (customerId, modelId) {
  //действия для обработки заказа
  return true
}
```
Также интерфейсы очень полезны, чтобы определить, что же должно присутствовать в том или ином классе:

```typescript
interface Car {
  width: number;
  length: number;
  wheelbase: number;
  seatingCapacity: number;
  getTyrePressure?: () => number;
  getRemCharging: () => number;
}

class CarModelPrototype implements Car {
  length: number;
  width: number;
  wheelbase: number;
  seatingCapacity: number;
  doorsRealisation: string;

  constructor(length: number, width: number, wheelbase: number, seatingCapacity: number) {
    this.length = length;
    this.width = width;
    this.wheelbase = wheelbase;
    this.seatingCapacity = seatingCapacity;
  }

  getTyrePressure(): number {
    return 20;//получено путём долгих вычислений
  }

  getRemCharging(): number {
    return 20;//получено путём долгих вычислений
  }
}
```
Сам по себе интерфейс ни во что не компилируется.
Ссылка на статью, где приводятся аналогии с реальной жизнью: https://blog.logrocket.com/interfaces-in-typescript-what-are-they-and-how-do-we-use-them-befbc69b38b3/

4. ### Что такое Enum и во что он компилируется

***Enum (Перечисление)*** - это тип данных в TS, который позволяет определять набор именованых числовых констант. перечисление
состоит из нуля или более элементов, каждый из которых имеет ассоциированное с ним значение. Перечисления бывают числовыми (numeric enums),
строчными (string-based enums), смешанными (heterogeneous enums).

Примеры числового:

```typescript
enum NoYes {
  No,
  Yes,
}

enum NoYes {
  No = 0,
  Yes = 1,
}
```
К слову, перечисление с примера выше компилируется в следующее:

```javascript
"use strict";
var NoYes;
(function (NoYes) {
  NoYes[NoYes["No"] = 0] = "No";
  NoYes[NoYes["Yes"] = 1] = "Yes";
})(NoYes || (NoYes = {}));
```
или же:

```typescript
var NoYes = {
  0: "No",
  1: "Yes",
  "No": 0,
  "Yes": 1,
}
```
Также, если мы присвоим какой-то из констант присвоить число, то следующей константе будет присвоено значение на один больше и т.д.

```typescript
enum AcceptedNumber {
  First = 5,
  Second,
  Third,
}

let secondNumber: AcceptedNumber = AcceptedNumber.Second;
let thirdNumber: AcceptedNumber = AcceptedNumber.Third;

console.log(secondNumber);//6
console.log(thirdNumber);//7
```
Пример строчного:

```typescript
enum PrintMedia {
  Newspaper = "NEWSPAPER",
  Newsletter = "NEWSLETTER",
  Magazine = "MAGAZINE",
  Book = "BOOK",
}
```
Пример смешанного:
```typescript
enum Status {
  Active = "Active",
  Deactivate = 1,
  Pending
}
```
5. ### Что такое геттеры и сеттеры в TypeScript?
***Геттеры и сеттеры*** - это методы класса (с ключевыми словами `get` и `set`), которые позволяют перехватить доступ к свойствам объектов. Они позволяют
более тщательно контролировать доступ к свойствам объекта.
```typescript
class WashingMachine {
  constructor(readonly name: string, private _amountOfPowderInMl: number) {}

  get amountOfPowderInMl(): number {
    return this._amountOfPowderInMl;
  }

  set amountOfPowderInMl(newAmount: number) {
    if (newAmount > 250) {
      console.log("Too much powder!");
    } else {
      this._amountOfPowderInMl = newAmount;
    }
  }
}

let washingMachine = new WashingMachine("Machine1000", 0);

washingMachine.amountOfPowderInMl = 300;//Too much powder!
console.log(washingMachine.amountOfPowderInMl);//0, свойство не назначилось, так как не прошло проверку.

washingMachine.amountOfPowderInMl = 200;
console.log(washingMachine.amountOfPowderInMl);//200
```
6. ### Generics (Обощенные типы)
***Generics (обобщенные типы, "дженерики")*** - это возможность создавать компоненты (функции, классы, интерфейсы), работающие не только с одним,
а с несколькими типами данных. С помощью дженериков можно создавать обобщённые функции, классы и интерфейсы.
Пример с обобщённой функцией:

```typescript
function print<T>(arg: T): T {
  return arg;
}

print("str");//str
print(42);//42
```
Например, в классе:

```typescript
class User<T, U> {
  name: T;
  age: U;

  constructor(name: T, age: U) {
    this.name = name;
    this.age = age;
  }

  print(): void {
    console.log(`Hello ${this.name}, you are ${this.age} years old!`);
  }
}

const newUser1 = new User("Leonardo", 23);
newUser1.print(); // Hello Leonardo, you are 23 years old!

const newUser2 = new User("Leonardo", "23");//если для age был бы указан тип number, то была бы ошибка.
newUser2.print();//Hello Leonardo, you are 23 years old!
```
Без generics на предпоследней строке была бы ошибка. Ведь если для `age` был бы указан тип
`number`, то при передаче строки в качестве второго аргумента появится ошибка "Argument of type 'string' is not assignable
to parameter of type 'number'".

Пример с интерфейсом:

```typescript
interface User {
  firstName: string;
}

interface Client {
  firstName: string;
  lastName: string;
}

interface Admin<T> {
  values: T;
  isAdmin: true;
}

const user: Admin<User> = {
  values: {
    firstName: "Leonardo"
  },
  isAdmin: true
};

const client: Admin<Client> = {
  values: {
    firstName: "Leonardo",
    lastName: "Maldonado"
  },
  isAdmin: true
};
```
Отличие **generics** от использования `any` в примерах выше в том, что не теряется проверка типов, просто типы можно использовать любые.
При использовании `any`, например, в функции, мы не можем быть уверены в том, что, приняв в качестве аргумента строку, функция
строку и вернёт, а если примет число, то число и вернёт. При использовании же generics - да.

Ссылка на понятную статью: https://blog.logrocket.com/getting-started-with-typescript-generics/

7. ### Как сделать так, чтобы классы, объявленные в модуле, были бы доступны и за пределами этого модуля?
При помощи ключевого слова `export`.

```typescript
module Vehicle {
  export class Car {
    constructor (public make: string, public model: string) { }
  }

  let audiCar = new Car("Audi", "Q7");
}

let fordCar = new Vehicle.Car("Ford", "Figo");
```
8. ### Поддерживает ли TypeScript перегрузку функций?

Да, TS поддерживает возможность перегрузки функций. "Перегрузить функцию" означает определить несколько
"версий" функции, которые будут иметь одно и то же имя, но разные типы параметров или разное количество параметров

```typescript
function add(x: string, y: string): string;
function add(x: number, y: number): number;
function add(x: any, y: any): any {
  return x + y;
}

let result1 = add(5, 4);
console.log(result1);// 9

let result2 = add("5", "4");
console.log(result2);// 54

//а вот так не сработает и выдаст ошибку:
let result3 = add(true, false);
console.log(result3);//no overload match this call
```
9. ### Как в TypeScript перегрузить конструктор класса?
- При помощи необязательного параметра:

```typescript
class Box {
  public x: number;
  public y: number;
  public height: number;
  public width: number;

  constructor();
  constructor(obj: IBox);
  constructor(obj?: any) {
    this.x = obj?.x|| 0;
    this.y = obj?.y || 0;
    this.height = obj?.height || 0;
    this.width = obj?.width || 0;
  }   
}
```
- При помощи типа-объединения:

```typescript
class foo {
  private _name: any;

  constructor(name: string | number) {
    this._name = name;
  }
}

let f1 = new foo("bar");
let f2 = new foo(1);
```
10. ### Разница между interface и type в TypeScript?

Разница между `interface` и `type` в том, что:  
- Интерфейсы позволяют выразить пересечение типов, однако не позволяют выразить объединение.
Пример ограничения на типах, которое невозможно на интерфейсах:

```typescript
type Wish =
  | { fast: true, quality: true, cheap: false } // Дорого
  | { fast: true, quality: false, cheap: true } // Некачественно
  | { fast: false, quality: true, cheap: true } // Медленно

const wish: Wish = { fast: true, quality: true, cheap: true } // Не компилируется
```
- Интерфейсы нельзя комбинировать с mapped типами (Partial, Required, Pick):

```typescript
// С типом работает
type RealProfile = Pick<TwitterProfile, 'drinkCoffee'>;

// С интерфейсом не работает
interface RealProfile extends Pick<TwitterProfile, 'drinkCoffee'> {}
```
- Интерфейсы поддерживают declaration merging - то есть слияние интерфейсов с одинаковыми именами:

```typescript
interface Employee {
  salary: number;
}

interface Employee {
  age: number;
}

const employee: Employee = { age: 23 };//Property 'salary' is missing in type '{age: number}', but required in type Employee
```
С `type` такого не происходит:
```typescript
type Employee = {//Duplicate identifier 'Employee'
  salary: number;
}

type Employee = {//Duplicate identifier 'Employee'
  age: number;
}

const employee: Employee = { age: 23 };//Type '{age: number}' is not assignable to type 'Employee'
```
Ссылка: https://teletype.in/@alteregor/rkPlgmQz8

11. ### Для чего нужен тип «Omit»?
Тип `Omit` нужен для того, чтобы указать свойства, которые должны быть исключены из исходного типа.

```typescript
type InhabitedPlanet = {name: string, age: number, population: number};
type UninhabitedPlanet = Omit<InhabitedPlanet, "population">;

let mercury: UninhabitedPlanet = {
  name: "Mercury",
  age: 4503e9,
};
```
12. ### Для чего нужен тип «Record»?

Тип `Record<Keys, Type>` создаёт тип cо свойствами `Keys` типа `Type`.

Например, следующую запись типа
```typescript
type PropResponse = {
  prop1: string
  prop2: string
  prop3: string
};
```
можно записать короче, используя `Record<Keys, Type`:
```typescript
type PropResponse = Record<'prop1' | 'prop2' | 'prop3', string>;
```
13. ### Когда используется ключевое слово «unknown»?

Когда заранее неизвестно, значение какого типа будет присвоено переменной. Потом тип можно проверить:

```typescript
let person: unknown = 'John';

if (typeof person === string) {
  let name: string = person;
}
```
14. ### Разница между абстрактным классом и интерфейсом typescript
- В интерфейсе все свойства являются по-умолчанию абстрактными, а в абстрактном классе некоторые абстрактные,
а некоторые могут быть полностью реализоваными (этим можно управлять).

Пример с интерфейсом:

```typescript
interface Person {
  name: string;
  display(name: string): void;//можно обозначить только, что этот метод должен присутствовать, но нельзя указать как именно он должен быть реализован.
}

class Employee implements Person {//class 'Employee' incorrectly implements interface 'Person'. Property 'display' is missing in type 'Employee' but required in type 'Person'
  name: string;
}
```
Пример с абстрактным классом:

```typescript
abstract class Person {
  abstract name: string;

  display(): void {
    console.log(this.name)//нужно указать реализацию метода
  }
}

class Employee extends Person {//никакой ошибки не будет, метод display необязательный
  name: string;
}
```
- Интерфейсы поддерживают множественно наследование, а абстрактные классы нет.
Множественное наследование - это наследование от более чем одного родителя.

Пример с интерфейсом:

```typescript
interface IPerson {
  name: string;
}

interface IHuman {
  gender: string;
}

interface IAdult extends IPerson {
  empCode: number;
}

interface IAdult extends IHuman {
  hairColor: string
}

let empObj: IEmployee = {//всё ок, никакой ошибки
  empCode: 1,
  name: "Bill",
  gender: "Male",
  hairColor: "dark",
}
```
Пример с абстрактным классом:
```typescript
abstract class Person {
  name: string;
}

abstract class Human {
  gender: string;
}

abstract class Adult extends Person {//Duplicate identifier 'Adult'
  name: string;
  empCode: number;
}

abstract class Adult extends Human {//Duplicate identifier 'Adult'
  hairColor: string;
  gender: string;
}
```
- Интерфейс сам по себе ни во что не компилируется, абстрактный класс же компилируется в JS.
15. ### Когда нужно использовать ключевое слово «declare»?
Ключевое свойство "declare" нужно использовать при использовании библиотеки JS, не объявленной в TS-проекте:

```typescript
declare const libraryName;
```
16. ### Как сделать все свойства интерфейса необязательными?
- При помощи `?` в конце названия свойства (например, `title?: `, `description?: `).

Например:
```typescript
interface Todo {
  title?: string;
  description?: string;
}

const todo: Todo = {
  title: "organize desk",
};//это не вызовет ошибки, потому что свойства необязательные:
```

- При помощи `Partial<Type>`:

```typescript
interface Todo {
  title: string;
  description: string;
}

const todo: Partial<Todo> = {};//ошибки никакой не будет, потому что все поля интерфейса необязательные
```

а также:

```typescript
interface Todo {
  title: string;
  description: string;
}

type Part<T> = {
  [P in keyof T]?: T[P];
};

type PartialTodo = Part<Todo>;

const todo: PartialTodo = {};
```
17. ### Использовании декораторов свойств в TypeScript
Декоратор свойства позволяет добавить ему дополнительное свойство:

```typescript
function format(target: any, propertyKey: string) {
  let _val = target[propertyKey];// получаем значение свойства

  // геттер
  let getter = function() {
    return 'Mr./Ms.' + _val;
  };

  // сеттер
  let setter = function(newVal: string) {
    _val = newVal;
  };

  // удаляем свойство
  if (delete target[propertyKey]) {
    // И создаем новое свойство с геттером и сеттером
    Object.defineProperty(target, propertyKey, {
      get: getter,
      set: setter,
    })
  }
}

class User {
  @format
  name: string;

  constructor(name: string) {
    this.name = name;
  }

  print(): void {
    console.log(this.name);
  }
}

let tom = new User('Tom');

tom.print();//Mr./Mr.Tom
tom.name = 'Tommy';
tom.print();//Mr./Mr.Tommy
```

18. ### Что такое «.map» файл, как и зачем его использовать?

Файл ".map" - это файл карты исходников, который можно использовать при выполнении
отладки. Его можно сгенерировать, установив опцию компилятора *sourseMap* в true в файле tsconfig.json

## Angular
1. ### Метаданные компонента и какие из них обязательные
2. ### Хуки компонента
3. ### Как написать структурную директиву
4. ### Разница между ViewChild и ContentChild
5. ### ngContent, ngContainer, ngTemplate
6. ### hostListener и hostBinding
7. ### change detection
8. ### dependency injection
9. ### Как заинжектить переменную
10. ### Разница между объявлениями сервиса в компоненте или модуле
11. ### Виды форм
12. ### Что такое router-outlet
13. ### Как создать дочерний маршрут
14. ### Виды guard
15. ### Виды pipe
16. ### Для чего испольуется zone.js
17. ### Tasks в zone.js
18. ### Как протестировать асинхронный код
19. ### Любые способы передать данные между двумя компонентами, даже самые нелепые
20. ### Разница между AOT, JIT
