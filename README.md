# javascript-and-angular-interview-questions

JavaScript and Angular Interview Questions &amp; Answers

## Содержание

| № | Questions |
|---- | ---------
| I| [Основы](#Основы) |
| 1| [Чистота функции](#чистота-функции) |
| 2| [Что такое императивное программирование](#что-такое-императивное-программирование) |
| 3| [Что такое декларативное программирование](#что-такое-декларативное-программирование) |
| 4| [Что такое функция высшего порядка](#что-такое-функция-высшего-порядка) |
| 5| [Функциональное программирование](#Функциональное-программирование) |
| 6| [Реактивное программирование](#Реактивное-программирование) |
| 7| [Методологии разработки](#Методологии-разработки) |
| 8| [ООП](#ООП) |
| 9| [SOLID](#SOLID) |
| II| [HTML](#HTML) |
| III| [CSS](#CSS) |
| IV| [JavaScript](#JavaScript) |
| 1| [Типы данных](#Типы-данных) |
| 2| [Область видимости](#область-видимости) |
| 3| [Lexical environment](#Lexical-environment) |
| 4| [Замыкание](#Замыкание) |
| 5| [Hoisting](#Hoisting) |
| 6| [Разница между function expression и function declaration](#Разница-между-function-expression-и-function-declaration) |
| 7| [Способы создать объект](#Способы-создать-объект) |
| 8| [this](#this) |
| 9| [Что такое цепочка прототипов](#Что-такое-цепочка-прототипов) |
| 10| [Разница между for in и for of](#Разница-между-for-in-и-for-of) |
| 11| [Разница между методами массива slice и splice](#Разница-между-методами-массива-slice-и-splice) |
| 12| [Разница между == и ===](#Разница-между-==-и-===) |
| 13| [Каррирование](#Каррирование) |
| 14| [Разница между let и var](#Разница-между-let-и-var) |
| 15| [Что такое временная мертвая зона](#Что-такое-временная-мертвая-зона) |
| 16| [Классы в es6](#Классы-в-es6) |
| 17| [Что такое деструктуризация](#Что-такое-деструктуризация) |
| 18| [Способы привязать контекста к функции](#Способы-привязать-контекста-к-функции) |
| 19| [Прототипное наследование](#Прототипное-наследование) |
| 20| [Функциональное наследование](#Функциональное-наследование) |
| 21| [Назначение super в классе](#Назначение-super-в-классе) |
| 22| [Разница между obj.\_\_proto__ и obj.Prototype](#Разница-между-obj.\_\_proto__-и-obj.Prototype) |
| V| [TypeScript](#TypeScript) |
| 1| [Суть TypeScript в разработке](#Суть-TypeScript-в-разработке)
| 2| [Какие есть типы данных](#Какие-есть-типы-данных)
| 3| [Что такое Interface и во что он компилируется](#Что-такое-Interface-и-во-что-он-компилируется)
| 4| [Что такое Enum и во что он компилируется](#Что-такое-Enum-и-во-что-он-компилируется)
| 5| [Что такое геттеры и сеттеры в TypeScript?](#Что-такое-геттеры-и-сеттеры-в-TypeScript?)
| 6| [Generics (Обощенные типы)](#Generics-(Обощенные-типы))
| 7| [Как сделать так, чтобы классы, объявленные в модуле, были бы доступны и за пределами этого модуля?](#Как-сделать-так,-чтобы-классы,-объявленные-в-модуле,-были-бы-доступны-и-за-пределами-этого-модуля?)
| 8| [Поддерживает ли TypeScript перегрузку функций?](#Поддерживает-ли-TypeScript-перегрузку-функций?)
| 9| [Как в TypeScript перегрузить конструктор класса?](#Как-в-TypeScript-перегрузить-конструктор-класса?)
| 10| [Разница между interface и type в TypeScript?](#Разница-между-interface-и-type-в-TypeScript?)
| 11| [Для чего нужен тип «Omit»?](#Для-чего-нужен-тип-«Omit»?)
| 12| [Для чего нужен тип «Record»?](#Для-чего-нужен-тип-«Record»?)
| 13| [Когда используется ключевое слово «unknown»?](#Когда-используется-ключевое-слово-«unknown»?)
| 14| [Разница между абстрактным классом и интерфейсом typescript](#Разница-между-абстрактным-классом-и-интерфейсом-typescript)
| 15| [Когда нужно использовать ключевое слово «declare»?](#Когда-нужно-использовать-ключевое-слово-«declare»?)
| 16| [Как сделать все свойства интерфейса необязательными?](#Как-сделать-все-свойства-интерфейса-необязательными?)
| 17| [Использовании декораторов свойств в TypeScript](#Использовании-декораторов-свойств-в-TypeScript)
| 18| [Что такое «.map» файл, как и зачем его использовать?](#Что-такое-«.map»-файл,-как-и-зачем-его-использовать?)
| VI| [Angular](#Angular) |
| 1| [Метаданные компонента и какие из них обязательные](#Метаданные-компонента-и-какие-из-них-обязательные)
| 2| [Хуки компонента](#Хуки-компонента)
| 3| [Как написать структурную директиву](#Как-написать-структурную-директиву)
| 4| [Разница между ViewChild и ContentChild](#Разница-между-ViewChild-и-ContentChild)
| 5| [ngContent, ngContainer, ngTemplate](#ngContent,-ngContainer,-ngTemplate)
| 6| [hostListener и hostBinding](#hostListener-и-hostBinding)
| 7| [change detection](#change-detection)
| 8| [dependency injection](#dependency-injection)
| 9| [Как заинжектить переменную](#Как-заинжектить-переменную)
| 10| [Разница между объявлениями сервиса в компоненте или модуле](#Разница-между-объявлениями-сервиса-в-компоненте-или-модуле)
| 11| [Виды форм](#Виды-форм)
| 12| [Что такое router-outlet](#Что-такое-router-outlet)
| 13| [Как создать дочерний маршрут](#Как-создать-дочерний-маршрут)
| 14| [Виды guard](#Виды-guard)
| 15| [Виды pipe](#Виды-pipe)
| 16| [Для чего испольуется zone.js](#Для-чего-испольуется-zone.js)
| 17| [Tasks в zone.js](#Tasks-в-zone.js)
| 18| [Как протестировать асинхронный код](#Как-протестировать-асинхронный-код)
| 19| [Любые способы передать данные между двумя компонентами, даже самые нелепые](#Любые-способы-передать-данные-между-двумя-компонентами,-даже-самые-нелепые)
| 20| [Разница между AOT и JIT](#Разница-между-AOT-и-JIT)

## Основы

1. ### Чистота функции

***Чистая функция*** - это функция, которой присущи следующие характеристики:
- Принимает на вход аргументы
- При одних и тех же аргументах возвращает одни и те же значения
- Не меняет внешний контекст
- Не вызывает нечистые функции
- Не имеет побочных эффектов

##### Пример:

```javascript
function getWordCount(arr) {
  return arr.length;// этой функции присущи все вышеобозначенные характеристики
}
```   
***Нечистая функция*** - это функция, которой, соответственно, обозначенные выше характеристики не присущи.

К ***побочным эффектам*** функции относят вызовы API, манипулирование DOM-ом, запись в базу данных, чтение и модификация глобальных переменных.

2. ### Что такое императивное программирование
***Императивное программирование*** - это способ написания кода, в котором фокусом есть *описание логики* работы программы. К такому коду можно поставить вопрос **"Как именно мы что-то делаем?"**.
##### Пример:
Нужно написать функцию, которая принимает массив, а возвращает сумму значений массива. Императивным подходом это решается следующим образом:

```javascript
function add(arr) {
  let result = 0;
  for(let i = 0; i < arr.length; i++) {
    result += arr[i];
  }
  return result;
}
```
Как видно из примера - мы описали как именно мы достигаем решения поставленной задачи (сначала у нас результат 0, потом проходимся по массиву, потом возвращаем результат).

3. ### Что такое декларативное программирование
***Декларативное программирование*** - это способ написания кода, в котором фокусом есть *указание результата*, который мы хотим получить. К такому коду можно поставить вопрос **"Что именно мы получаем?"**
#### Пример:
Задача стоит такая же, как и в предыдущем пункте. Декларативным подходом это решается следующим образом:

```javascript
function add(arr) {
  return arr.reduce((prev, current) => prev + current, 0);
}
```

Как видно из примера - мы пишем ***ЧТО*** мы хотим получить, и не задумываемся, как именно оно получится. Но, понятное дело, что под этой декларативной записью скрывается что-то императивное, но оно скрыто.

Ссылка на статью, где приводятся аналогии с реальной жизнью: https://ui.dev/imperative-vs-declarative-programming/  

4. ### Что такое функция высшего порядка
***Функция высшего порядка*** - это функция, которая принимает на вход другие функции, или же возвращает другие функции.
#### Примеры:
```javascript
function sayHi() {
  alert('Hi!');
}

function greet(greeting) {
  greeting();
}

greet(sayHi);// передаём функцию sayHi в качестве аргумента функции greet.
```   
а также:

```javascript     
function whenMeetingJohn() {
  return function() {
    alert('Hi!);
  }
}

let atLunchToday = whenMeetingJohn();
atLauchToday();
```

5. ### Функциональное программирование
***Функциональное программирование*** - это одна из парадигм программирования, которая базируется на следующих принципах:

   - основные функции реализованы с **использованием чистых функций без побочных эффектов**
   - **данные не изменяются**
   - функциональные программы **не имеют состояния**
   - императивный код **контейнера (нечистая функция) управляет побочными эффектами и выполняет декларативный**, чистый код ядра.

#### Пример:

```javascript        
const fpCopy = `Functional programming is powerful and enjoyable to write. It's very cool!`;

// все функции, кроме последней - чистые. Не изменяют никакие данные.
const stripPunctuation = (str) => str.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, '');

const getArr = (str) => str.split(' ');

const getWordCount = (arr) => arr.length;

const getKeywords = (arr) => arr
  .filter(item => item.length > 5)
  .map(item => item.toLowerCase());

// это контейнер, который является нечистой функцией. Управляет побочными эффектами и выполняет предыдущие чистые функции
function processCopy(str, prepFn, arrFn, countFn, kwFn) {
  const copyArray = arrFn(prepFn(str));
  return `Word count: ${countFn(copyArray)}, keywords: ${kwFn(copyArray)}`;
}

processCopy(fpCopy, stripPunctuation, getArr, getWordCount, getKeywords);
```   

6. ### Реактивное программирование
***Реактивное программирование*** - это парадигма программирования, которая заключается в декларативным наблюдении и реагировании на поступающие события во времени.  

7. ### Методологии разработки
 - Agile
   * экстремальное программирование (Extreme Programming, XP); <br>
   ***Цель*** - справиться с постоянно меняющимися требованиями к программному продукту и повысить качество разработки. 4 принципа:<br>
     1) **Кодирование** согласно единым в команде стандартам оформления.
     2) **Тестирование**. Тесты пишут сами программисты ещё до написания кода, который будут тестировать.
     3) **Планирование**. И финальное и отдельных итераций. (В среднем раз в две недели)
     4) **Слушание**. И разработчиков, и клиента. Цель - устранить неясности и недопонимания, определить четкие требования и ценности.

   * бережливая разработка программного обеспечения (Lean); <br>
   ***Цель*** - повышение эффективности процесса разработки, минимизация затрат.<br>
     1) **Избавление от потерь** (плюс к качеству). Если что-то не нужно, то его лучше убрать.
     2) **Постоянное обучение команды (плюс к эффективности)**
     3) **Принятие решения так поздно, как только можно.** Решения должны быть продуманными и взвешенными. (плюс к эффективности и качеству)
     4) **Быстрая доставка**
     5) **Усиление команды.** “Люди и взаимодействие важнее процессов и инструментов”. То, как люди в команде могут взаимодействовать и кооперироваться - важнее даже того, какие инструменты они используют. (плюс к эффективности)
     6) **Целостность и качество.** Изначально нужно делать качественный продукт, то есть не избавляться от проблем и багов, а пресечь их появление (плюс и к эффективности, и к качеству). + **Видение цельной картины.** Нужно чётко понимать, какой текущий статус разработки, какие цели, концепции и стратегии у разрабатываемого ПО
   * фреймворк для управления проектами Scrum;<br>
   ***Scrum*** - методология управления проектами, сутью котого есть постоянная вовлеченность в процесс разработки кроме специалистов ещё и владельца продукта (человек, который соединяет команду с заказчиком, мониторит развитие проекта) + scrum-master (человек, который проводит совещания, мотивирует команду, мониторит соблюдение самого scrum). По Scrum рабочий процесс делится на спринты (некоторые промежутки времени, от недель до месяца). Каждый раз перед началом нового спринта формулируются цели и задачи, которые нужно достичь/решить, в конце каждого спринта обсуждаются результаты, успехи либо фейлы. Что удобно - можно сравнивать эти самые спринты, оценивать эффективной работы, ею управлять.   
   * разработку, управляемую функциональностью (Feature-driven development, FDD);
   * разработку через тестирование (Test-driven development, TDD); <br>
   Методология разработки ПО, которое основывается на повторении коротких циклов разработки:
     1) Пишется тест, который покрывает нужные изменения;
     2) Пишется код, который желаемые изменения, собственно, реализует и позволяет пройти тест.
     3) Проводится рефакторинг написанного кода.

   * методология «чистой комнаты» (Cleanroom Software Engineering); <br>
     Процесс разработки программного обеспечения, который предназначен для создания ПО с сертифицируемым уровнем надежности. Основной принцип: предупреждение проблем (дефектов) лучше, чем их устранение. <br>
     Основан на следующем:
     1) Разработка ПО основывается на формальных методах;
     2) Инкрементальная реализация в рамках статистического контроля качества.
     3) статистическое тестирование;
     4) формальная верификация.

   * итеративно-инкрементальный метод разработки (OpenUP); <br>
   Метод разработки, который делит цикл проекта на четыре фазы:
     1) Начальная фаза
     2) Фаза уточнения
     3) Фаза конструирования
     4) Фаза передачи.

   * методологию разработки Microsoft Solutions Framework (MSF); <br>
   Методология, которая базируется на 8 принципах:
     1) Cвободный и открытый обмен инфой между участников внутри команды и заинтересованными сторонами. (снижает вероятность недопонимания и переделывания работы)
     2) Общий взгляд участников команды на результат, понимание в равной степени всеми целей и задач, над которыми ведётся работа.
     3) Каждый участник обладает максимально полными полномочиями, которые нужны для выполнения задачи.
     4) Разделение ответственности. Все успехи и неудачи команды делятся поровну.
     5) Ориентировка на клиента, на его потребности.
     6) Готовность к переменам требований, условий.
     7) Раннее выявление ошибок и недочетов, которое реализуется на протяжении всего проекта.
     8) Развитие сотрудников, обмен информацией и опытом.

   * метод разработки динамических систем (Dynamic Systems Development Method, DSDM); <br>
   Метод разработки, который основан на концепции быстрой разработки приложений.
   9 принципов DSDM: <br>
     1) Вовлечение пользователя. Для более точного принятия решения разработчики делят с пользователями рабочее пространство.
     2) Необходимость, чтобы команда могла самостоятельно принимать решения (без предварительного согласования с начальством)
     3) Принцип "лучше сделать раньше, но просто хорошо, чем отлично, но в самом конце"
     4) Быстрая доставка ПО, которое удовлетворяет текущим потребностям рынка.
     5) Итеративная (т.е такая, которая происходит с непрерывным анализом полученных результатов и коректировкой предыдущей работы) и инкреметная разработка
     6) любые изменения во время разработки обратимы.
     7) требования формулируются на высоком уровне прежде, чем начнётся проект.
     8) в жизненный цикл разработки обязательно интегрируется тестирование.
     9) крайне необходимо взаимодействие и сотрудничество между всеми учасниками (плюс к эффективности)

   * метод управления разработкой Kanban. <br>
   Kanban держится на 4 столбах: <br>
     1) "Карточки". Для каждой задачи - отдельная карточка, где записана вся необходиммая инфа.
     2) Ограниченное количество задач на одном этапе.
     3) Непрерывный поток.
     4) Постоянное улучшение и совершенствование. То есть постоянный и непрерывный анализ производственного процесса + поиск путей дял повышения производительности.

 - ***Waterfall*** (или же каскадная модель) - модель процесса разработки, которая делит создание проекта на несколько частей (а именно анализ требований, проектирование, реализация, тестирование, интеграция и поддержка), которые следуют один за другим (как поток). Суть в том, что один этап разработки **не может начаться**, пока не завершится другой. Основные принципы - **строгая последоватеьность** и **однократное выполнение** каждоого этапа.

 - ***Спиральная модель*** - модель разработки ПО, которая сочетает идеи итеративной и каскадной моделей. Создание проекта также делится на этапы, но (поскольку у нас спиральная модель) эти этапы повторяются на каждом новом "витке". Просто на выходе с каждого "витка" мы получаем протестированный "прототип", который дополняет существующий билд и дальше начинаются те же этапы и т.д, до тех пор, пока не получим прототип, который удовлетворяет всем требованиям.
8. ### ООП
***ООП*** - парадигма программирования, в которой основными концепциями являются понятия объектов и классов.<br>
Базовыми принципами ООП есть следующие:
- **Абстрагирование**. Означает, что нужно выделить некий набор характеристик объекта. Характеристики должны быть значимыми. **Абстракция**, в свою очередь - это набор значимых характеристих объекта.
- **Инкапсуляция**. То, что помогает "защитить" жизненно важные данные для компонента, а также скрыть детали реализации от пользователя. Но последний, в свою очередь, может взаимодействовать с компнентом при помощи некоего интерфейса.
- **Наследование**. Способность объекта или класса базироваться на другом объекте или классе, способность одного объекта приобретать свойства другого, добавлять к ним что-то, что характерно только для него. Через наследование чётко видна их иерархия.
- **Полиморфизм**. Реализация одной и той же задачи разными способами.<br><br>
  Также используются правило **DRY (Don't repeat yourself)**, то есть правило того, что каждая инфа, кадый кусочек кода должен быть представлен в единственном числе в одном месте программмы + принципы **SOLID**.
9. ### SOLID
***SOLID*** - это набор из 5 принципов (сам термин - это акроним из названий этих принципов), который помогает делать код как-будто действительно очень устойчивым и крепким (а слово "solid" с англ так и переводится), читай хорошо организованным, понятным и поддерживаемым, там, где уж точно какое-то изменение в дальнейшем не будет иметь результатом полный крах всего :).<br>
Итак, эти принципы:
- **Single Responsibility Principle (принцип персональной ответственности)**<br>
   Класс должен иметь лишь одну ответственность, то есть должен отвечать только за одну вещь, на него возложена одна единственная обязанность. Другими словами, Do one thing and do it well!
- **Open/Closed Principle (Принцип открытости/закрытости)**<br>
   Программные сущности должны быть открыты для расширения, но закрыты для изменения.
   Иными словами, следует создавать классы таким образом, чтобы со временем можно было дополнить их функционал, но при этом не нужно было затрагивать старый код. Эффективно и быстрее писать новое, расширять уже существующее, при этом не пересматривая и не переделывая уже написанное.
- **Liskov Substitution Principle**<br>
   Объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.
- **Interface Segregation Principle**<br>
   Клиенты не должны зависеть от методов, которые они не используют.
- **Dependency Inversion Principle**<br>
   Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

   3 статьи, где объясняются эти 5 принципов:

    * https://webdevblog.ru/solid-principy-chast-1/ (1 и 2 принципы).
    * https://webdevblog.ru/solid-principy-chast-2/ (3 принцип).
    * https://webdevblog.ru/solid-principy-chast-3/ (4 и 5 принцип).


## HTML
## CSS
## JavaScript

1. ### Типы данных

В JavaScript существуют следующие типы данных:
  - ***Примитивные типы данных (примитивы):***
    * **Number**

       Кроме чисел в привычном понимании этого слова, к этому типу данных относятся ещё `Infinity`, `-Infinity` и `NaN`.
       Обычные числа хранятся в 64-битном формате IEEE-754 (числа с плавающей запятой двойной точности): 52 из них используются для хранения цифр,
       11 - для положения десятичной точки, 1 - для знака. Диапазон: от -2^53 до 2^53. Для чисел, которые больше этого, используется другой тип данных BigInt.
    * **BigInt**

       Для создания bigInt нужно добавить в конец целочисленного литерала `n`. Например: `10n`, `9007199254740991n`
    * **String**

       Для создания строки используются одинарные, двойные или обратные кавычки. Формат - UTF-16
    * **Boolean**

       Тип данных, который принимает только 2 значения: `true` и `false`.
    * **Null**

       Тип данных, который содержит только значение `null`. Это значение представляет собой "ничего", "пусто" или "значение неизвестно".
    * **Undefined**  

       Тип данных, который содержит только значение `undefined`. Это значение означает, что "значение неприсвоено".
    * **Symbol**

       Символ - это уникальный идентификатор. Использутся в качестве ключа для свойства объекта. Позволяют создавать "скрытые" свойства объектов, к которым нельзя нечаянно обратиться и перезаписать из других частей программы.
  - ***Непримитивные***:
    * **Object**

       Объект - тип данных, который используется для хранения множества значений и сложный сущностей. Объект состоит из полей, каждый из которых является парой *ключ - значение*. Объекты таже называют "ссылочным типом".

Разница между примитивамы и непримитивами (объектами) в том, что:
   - примитивные типы данных содержат только одно значение, в то время как объект - это набор из множества данных.
   - примитивные типы данных не изменяемы, а объекты изменяемы.
   - примитивы сравниваются по значению, то есть примитивы будут строго равны, если они имеют одно значение. Объекты не сравниваются по значению. Даже если
   два объекта имеют одинаковые ключи и значения, то они не будут строго равны.

2. ### Область видимости
***Область видимости (Scope)*** можно определить как некий механизм, который собирает и обслуживает список поиска всех объявленных переменных. Область видимости делится на 2 категории: **лексическая** (другое, и более понятное, название **статическая**) область видимости и **динамическая** область видимости. Отличие первой от второй в том, что при первой "границы" области видимости устанавливаются во время объявления функции (другими словами во время компиляции, т.е первого прохода интерпретатора по коду), а не во время выполнения. То есть, неважно где функция была вызвана, важно то, где она была объявлена. В JS используется первый тип области видимости.   
#### Например:
```javascript
let a = 5;

function myFunc() {
  return a;
}

function myFunc2() {
  let a = 10;
  return myFunc();
}

myFunc2();// 5
```   
В этом примере результатом будет 5, потому что функция myFunc "видит" только a = 5. Это "видение" закрепилось во время объявления функции.  
Также область видимости можно поделить на:
   - **глобальную область видимости** (доступна всем)
   - **функциональную область видимости** (всё, что находится в пределах функции "видно" только внутри функции)
   - **блочную область видимости** (ограничена блоком кода).  
3. ### Lexical environment  

***Лексическое окружение*** - это связь сущности с контекстами её породившими (контекст выполнения, к слову, это некая концепция, которая описывает окружение в котором производится выполнение кода. Каждый контекст помещается в стек вызовов, потом удаляется). Технически, лексическое окружение является **объектом**, который имеет два свойства: *запись окружения* (в котором хранятся объявления) и *ссылку на лексическое окружение порождающего контекста*.  
Например:  
```
myFuncLexicalEnvironment = {
  environmentRecord: {
    someVariable : 5,
    someFunction: < somefunction function reference>
  }
  outer: <globalLexicalEnvironment>
}
```
Это лексическое окружение образуется во время вызова следующей функции:
```javascript
function myFunc() {
  let someVariable = 5;

  return function someFunction() {
    return someVariable;
  };
}

let f = myFunc();
```
Лексическое окружение создаётся на этапе создания контекста (например, вызова функции, выполнения блока кода *if*) и помещение его в стек вызовов. Поиск переменных через лексическое окружение схож по принципу работы на область видимости, но лексическое окружение нужно ещё для одной важной вещи: при удалении контекста выполнения из стека, его лексическое окружение "живёт" до тех пор, пока есть ссылка на него (например, есть хотя бы одна вложення функция, которая ссылается на него).  

4. ### Замыкание
***Замыкание*** - это функция, которая запоминает свои внешние переменные и может получить к ним доступ. В JS функции изначально являются замыканиями. Замыкания возможны благодаря лексическому окружению, которое было рассмотрено в предыдущем пункте.  

5. ### Hoisting  
***Hoisting*** (*поднятие*, *всплытие*) - это механизм в JS, в котором объявления переменных (объявленных через `var`; объявленные через `let` тоже всплывают, но у них есть особенность, о которой ниже) и объявления функций (т.е *function declaration*) передвигаются вверх по своей области видимости. Таким образом, мы можем вызывать функции, объявленные через *function declaration* до их объявления. И обращаться к переменным, объявленным через `var` до их объявления.
```javascript
myFunc();//'Hello!', объявление функции "всплыло" и она теперь как бы находится перед вызовом

function myFunc() {
  return 'Hello!';
}
```
```javascript
console.log(a);//undefined, всплыло только объявление

var a = 5;
```
Интересные примеры:
```javascript
var test = 6;

function test() {}

console.log(typeof test);//number
```
а тут:
```javascript
var test;

function test() {}

console.log(typeof test);//function
```

6. ### Разница между function expression и function declaration

Основное различие между ними в том, что функции, объявленные как *Function Declaration*, создаются интерпретатором до выполнения кода (связано с всплытием), а функции, объявленные при помощи Function Expression, создвются во время выполнения выражения. Поэтому их можно вызывать до объявления функции:
```javascript
sayHi("Veronica");//Hello, Veronica

function sayHi(name) {
  return(`Hello, ${name}`);
}
```
С Function Expression такого не будет:
```javascript
sayHi('Veronica');//будет ошибка

let sayHi = function(name) {
  return(`Hello, ${name}`);
}
```
7. ### Способы создать объект

Существует 3 способа создать объект:  
  - Через литерал объекта:

```javascript
let obj = {};
```
  - Через функцию-конструктор:

```javascript
function myFunc() {}

let obj = new myFunc();
```

  - Через Object.create():

```javascript
let obj = Object.create(obj2);//но здесь obj2 мы устанавливаем как прототип для obj
```
8. ### this
- Значение this в глобальном контексте зависит от того, используется ли `use strict` или нет. В `use strict` значение `this === undefined`, в нестрогом - `this === window` (это в браузерах).
- `this` внутри функции ссылается на внешний контекст:

```javascript
function myFunc() {
  'use strict'
  return this;
}

myFunc();//undefined, потому что используется 'use scrict'
```
  - В контексте объекта (и в методах) `this` ссылается на этот объект:

```javascript
let obj = {
  objProperty: "propertyValue",
  objMethod() {
    return this.objProperty;
  }
}

var objProperty = "this is a global window property";//var здесь и далее используется для наглядности

obj.objMethod();//propertyValue
obj.objMethod.call(window);//this is a global window property
```

  - Используя методы call() и apply(), можно вызывать функцию в нужном контексте:

```javascript
function myFunc() {
  return this.a + this.b;
}

let obj = {
  a: 1,
  b: 2,
}

var a = 6;
var b = 10;

myFunc();//16
myFunc.call(obj);//3
```

  - При помощи bind() можно создать новую функцию на основе имеющейся и привязать ей нужный контекст:

```javascript
function a() {
  return this.b;
}

let obj = {b: "objb"};
var b = "globalb";
let func = a.bind(obj);

a();//globalb
func();//objb
```

  - У стрелочных функций нет своего `this`. Значение берётся снаружи:

```javascript
let obj = {
  name: 'obj',
  letters: ['a', 'b', 'c'],

  showLetters() {
    this.letters.forEach(item => `${this.name}: ${item}`);
  }
};

obj.showLeters();//obj: a, obj: b, obj: c
```
  - Если использовать функцию как обработчик события, то `this` присваивается элементу, с которого начинается событие
  - В инлайновом обработчике, `this` указывает на DOM элемент, в котором расположен код события.

9. ### Что такое цепочка прототипов
***Цепочка прототипов*** - это некий механизм, которые позволяет одним объектам использовать свойтсва и методы, которые определены в других объектах, которые являются для первых прототипами.  
В JS вообще каждый объект имеет объект-прототип, который выступает как шаблон, от которого объект наследует методы и свойства. Реализуется это при помощи цепочки прототипов.  

Пример:

 ```javascript
let obj1 = {
  name: "obj1",
  isAlive: true,
};

let obj2 = {
  name: "obj2",
  isHappy: true
};

let obj3 = {
  name: "obj3",
};

//создаём цепочку:
obj2.__proto__ = obj1;
obj3.__proto__ = obj2;

//Проверяем:
console.log(obj3.__proto__.__proto__);//будет obj1

//но также:
console.log(obj3.__proto__.__proto__.__proto__);//Object {}

//конец цепочки:
console.log(obj3.__proto__.__proto__.__proto__.__proto__)//null

//проверяем доступ к свойствам прототипов:
console.log(obj3.isHappy);//true, такого свойства нет у obj3, но есть у его прототипа
console.log(obj3.isAlive);//true, такого свойства нет у obj3, но есть у прототипа его прототипа
 ```

10. ### Разница между for in и for of
- `for...of` вызывает на каждом шаге итерации **значение**, а не ключ. `for...in` вызывает на каждом шаге итерации **ключ**, а не значение.
- `for...of` работает с перебираемыми объектами.
11. ### Разница между методами массива slice и splice  

- Метод `slice` имеет синтаксис `arr.slice([start], [end])` и предназначен для **копирования элементов из массива `arr`**. Возвращает **новый** массив скопированных элементов (начиная со `start` и заканчивая `end` не включая). **Копирование** подразумевает, что **исходный массив не изменяется**:

```javascript
let arr = [1, 2, 3, 4, 5];
let newArr = arr.slice(0, 3);

console.log(arr);//[1, 2, 3, 4, 5], исходный массив остался прежним
console.log(newArr);//[1, 2, 3]
```

- Метод `splice` имеет синтаксис `arr.splice(index [, deleteCount, elem1, ..., elemN])` и предназначен для **удаления из массива `arr` `deleteCount` элементов, начиная с `index`**, а также вставки элементов `elem1` и т.д на их место. Возвращает массив удалённых элементов. **Удаление** подразумевает, что **исходный массив меняется**:

```javascript
let arr = [1, 2, 3, 4, 5];
let newArr = arr.splice(0, 3);

console.log(arr);//[4, 5], исходный массив изменился!
console.log(newArr);//[1, 2, 3]
```
12. ### Разница между == и ===

Разница между `==` ("нестрогое равенство", "абстрактное равенство") и `===` ("строгое равенство", "идентичность") в том, что `==` перед сравнением выполнит приведение типов, а `===` этого не делает:

```javascript
let a = 5;
let b = '5';

console.log(a == b);//true
console.log(a === b);//false
```
13. ### Каррирование
***Каррирование*** - одна из продвинутых техник для работы с функциями. Суть - в трансформации функции таким образом, чтобы они принимали аргументы не как f(a, b), а как f(a)(b):
```javascript
function curry(f) {
  return function(a) {
    return function(b) {
      return f(a, b);
    }
  }
}

function multiply(a, b) {
  return a * b;
}

let curriedMultiply = curry(multiply);
curriedMultiply(4)(5);//20
```
Можно применять, например, чтобы зафиксировать аргумент. Например, в коде выше можем создать функцию, вызывая которую, будем умножать какое-то фиксированное число на другое:
```javascript
//добавляем в код выше следующее:
let multiplyByFour = curriedMultiply(4);//фиксируем аргумент

multiplyByFour(5);//20
multiplyByFour(10);//40
```  
14. ### Разница между let и var  

Различия `var` и `let` в том, что:
   - У переменных `var` нет блочной области видимости. Они ограничиваются только телом функции (если объявлены в ней); `let` же "закрываются" в том блоке кода, в котором объявлены.

   Например, когда мы используем `var`:

```javascript
if (true) {
  var test = 5;
}

console.log(test);//5
```
   Но в то же время если использовать `let`:
```javascript
if (true) {
  let test = 5;
}

console.log(test);//ReferenceError: test is not defined
```
   - Объявление (но не присваивание!) `var` производится в начале исполнения функции или скрипта. Иными словами, объявление `var` всплывает. `let` тоже всплывает, но из-за ***мёртвой временной зоны*** (о ней ниже) мы не можем к ним обратиться раньше времени.

   Например, c `var`:

```javascript
function myFunc() {
  console.log(test);

  var test = 6;
}

myFunc();//undefined
```

   А с `let` будет следующее:
```javascript
function muFunc() {
  console.log(test);

  let test = 6;
}

myFunc();//ReferenceError: test is not defined
```
   - В браузере переменные, объявленные с помощью `var` становятся свойствами глобального объекта (поведение поддерживается для совместимости). У `let` такого поведения нет.
   Пример:

```javascript
var globalVar = 6;

console.log(window.globalVar);//6
```
   Но:
```javascript
let globalVar = 6;

console.log(window.globalVar);//undefined, такого свойства нет.
```
15. ### Что такое временная мертвая зона

***Временная мёртвая зона*** - это явление, которое блокирует доступ к поднятой переменной, объявленной через `let`, во избежание путаницы. Следующий код это наглядно демонстрирует:

```javascript
let x = 'outer value';

(function() {
  console.log(x);//Uncaught ReferenceError: Cannot access 'x' before initialization
  let x = 'inner value';
}());

```
Если бы `let` действительно не поднимались, то мы бы получили в результате 'outer value'. А из-за *временной мёртвой зоны* мы просто не можем обратиться к поднятой переменной, которую мы объявили в IIFE.

16. ### Классы в es6
***Классы в ES6*** - это более продвинутая конструкция, чем функции-конструкторы, своеобразная "надстройка":
```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }

  sleep(hours) {
    return(`${this.name} спит ${hours} часов`);
  }
}

let koala = new Animal("Коала");

koala.sleep(20);//Коала спит 20 часов

console.log(Animal === Animal.prototype.constructor);//true
console.log(Object.getOwnPropertyNames(Animal.prototype));//constructor, sleep
```
Используя же обычные функции-конструкторы код можно переписать следующим образом:
```javascript
function Animal(name) {
  this.name = name;
}

Animal.prototype.sleep = function(hours) {
  return(`${this.name} спит ${hours} часов`);
}

let koala = new Animal("Коала");
koala.sleep(20);//Коала спит 20 часов
```
Но всё же классы - это не совсем "синтаксический сахар" (т.е синтаксис для улучшения читаемости кода, но не делающий ничего принципиально нового). Есть несколько различий:
- Мы не можем вызвать класс без использования `new`, а функции можем.
- Методы класса - неперечисляемы. Определение класса устанавливает `false` для флага `enumerable` для всех методов, которые находятся в `prototype`.
- Весь код внутри классов автоматически находится в строгом режиме.  
17. ### Что такое деструктуризация
***Деструктуризация*** - это особый синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным, разбив его на части. Пример с массивом:
```javascript
'use strict';

let [firstName, lastName] = ["Имя", "Фамилия"];

console.log(firstName);
console.log(lastName);
```
Пример с объектом:
```javascript
'use strict';

let menu = {
  firstMeal: "soup",
  secondMeal: "pasta",
  beverage: "tea"
};

let {myFirstMeal, mySecondMeal, myBeverage} = menu;

console.log(myFirstMeal);//soup
console.log(mySecondMeal);//pasta
console.log(myBeverage);//tea
```
И если посложнее:
```javascript
let menu = {
  title: "Our Menu",
  sections: {
    firstMeals: ["soup", "borshsch"],
    secondMeals: ["pasta", "mashed potatoes"],
    beverages: ["tea", "coffee", "cola"],
  }
};

let {
  sections: {
    firstMeals,
    secondMeals,
    beverages,
  },
  pages = 20//в объекте menu такого нет
} = menu;

console.log(pages);//20
console.log(firstMeals);//["soup", "borshsch"]
console.log(secondMeals);//["pasta", "mashed potatoes"]
console.log(beverages);//["tea", "coffee", "cola"]
```
18. ### Способы привязать контекста к функции

- использовать bind:

```javascript
let obj = {
  firstValue: 5,
  secondValue: 6,
};

function add() {
  return this.firstValue + this.secondValue;
}

let addObjValues = add.bind(obj);

addObjValues();//11
```
- также для привязки контекста к функции подходят `call` и `apply`, но они используются для непосредственно вызова функции в том или ином контексте.

Пример с `call`:

```javascript
let student = {
  firstName: "John",
  lastName: "Miller",
};

function getFullName(firstName, lastName) {
  return `Full name: ${this.firstName} ${this.lastName}`;
}

getFullName.call(student, "firstName", "lastName");//Full name: John Miller
```
Пример с `apply`:

```javascript
let student = {
  firstName: "John",
  lastName: "Miller",
};

function getFullName(firstName, lastName) {
  return `Full name: ${this.firstName} ${this.lastName}`;
}

console.log(getFullName.apply(student, ["firstName", "lastName"]));//Full name: John Miller
```

19. ### Прототипное наследование
***Прототипное наследование*** - механизм в программировании, с помощью которого можно, за неимением в объекте собственного свойства или метода, найти их в объекте, который для этого объекта является прототипом. Если и в этом объекте этого свойства или метода нет, то найти в объекте, который для этого объекта является прототипом, и т.д.  

Пример прототипного наследования был дан в ответе на вопрос о [цепочке прототипов](#Что-такое-цепочка-прототипов)

20. ### Функциональное наследование  
***Функциональное наследование*** (*функциональный паттерн наследования*) - это такая организация наследования, при которой:
  - Родитель объявляется через функцию конструктор. У родителя могут быть приватные, публичные и защищённые свойства.
  - Для реализации наследования конструктор потомка вызывает родителя в своём контексте через `apply`/`call`. После этого может добавить свои переменные и методы.
  - Для расширения метода родителя этот метод копируется в переменную.  
 К слову, функциональное наследование применяется нечасто. Прототипный подход намного более используемый и обладает рядом преимуществ, также более понятен.  

Пример:
```javascript
function Machine() {
  let enabled = false;

  this.enable = function() {
    enabled = true;
  };

  this.disable = function() {
    enabled = false;
  };
}

function WashingMachine() {
  Machine.call(this);//реализуем наследование

  let powderAmountInMl = 0;

  this.setPowderAmountInMl = function(amountInMl) {
    powderAmountInMl = amountInMl;
  };
}

let washingMachine = new WashingMachine();

washingMachine.enable();//нам доступны методы родителя
washingMachine.disable();
washingMachine.setPowderAmountInMl(250);//также есть свои методы
```

21. ### Назначение super в классе

Ключевое слово ***super*** нужно для двух случаев:
- вызвать родительский метод (`super.method(...)`)
- вызвать родительский конструктор (`super(...)`)

22. ### Разница между obj.\_\_proto__ и obj.Prototype  

Через obj.\_\_proto__ мы можем получить объект, который является прототипом для этого объекта. В каждом объекте есть скрытое поле [[Prototype]], в котором хранится ссылка на прототип. Поскольку это поле скрыто и мы не может его получить напрямую, то используем obj.\_\_proto__.  
obj.prototype - это свойство функции-конструктора (в данном случае функции obj), в котором хранится объект, имеющий одно свойство constructor. Во время создания объектов при помощи функции-конструктора делается следующее: записывается в поле [[Prototype]] создаваемого объекта ссылка на объект, который хранится в obj.prototype. В этот же объект, к слову, записываются и все методы, которые будут наследоваться новосозданными при помощи функции-конструктора объектами.

```javascript
function Animal(name) {
  this.name = name;
}

Animal.prototype.sleep = function(hours) {
  return `${this.name} спит ${hours} часов в сутки`;
};

let koala = new Animal('Koala');

console.log(koala.__proto__ === Animal.prototype);//true
```

## TypeScript

1. ### Суть TypeScript в разработке
- Предотвращает появление множества багов. Следующий пример это хорошо демонстрирует:

```javascript
function getHumanReadableMessage(response) {
  if (response.data.hasSucceeded) {
    return `Your action succeeded because: ${response.message}`;
  }

  return `Something went wrong:(`;
}

const apiResponse = {
  data: {
    hasSucceeded: true,
    message: `Successful log in.`,
  },
};

console.log(getHumanReadableResponse(apiResponse));//Your action succeeded because: undefined
```
То есть, в приведённом выше примере не будет даже ошибки при выполнении, потому что в JS мы можем обращаться к
несуществующим свойствам объекта. Но это ведь не то, что нужно.

А вот если использовать TS:
```typescript
interface ApiResponse {
  data: {
    hasSucceeded: boolean;
    message: string;
  };
}

function getHumanReadableResponse(response: ApiResponse) {
  if (response.data.hasSucceeded) {
    return `Your action succeeded because: ${response.message}`;//ещё до компиляции получим ошибку, что свойство 'message' doesn't exist in type ApiResponse
  }

  return `Something went wrong:(`;
}

const apiResponse = {
  data: {
    hasSucceeded: true,
    message: `Successful log in.`,
  },
};

getHumanReadableResponse(apiResponse);
```
- Очевидно, что в связи с предыдущим пунктом значительно сокращается время разработки, так как не тратится время на выявление таких ошибок
- Строгая типизация избавляет от ручной проверки, например, типов аргументов в функции.
- Лучшая читаемость, поддерживаемость.

2. ### Какие есть типы данных  

В TS существуют следующие базовые типы данных (для тех, которые соотносятся с типами в JS, примеры не приводятся):
- `Boolean`
- `Number`
- `BigInt`
- `String`
- `Array`

Создать массив можно так:

```typescript
let list: number[] = [1, 2, 3, 4, 5];
```
А можно так (используя т.н *дженерик-тип*):

```typescript
let list: Array<number> = [1, 2, 3, 4, 5];
```

- `Tuple` (Кортежи)

Похожи на массивы, но имеют важную особенность: указывают на тип каждого элемента.
Очевидно, что кроме типов в создаваемом кортеже должно совпадать также количество
позиций.

```typescript
let tupleExample: [number, string, boolean] = [42, "tuple", true];
```

- `Enum` (Перечисление)

Перечисление позволяет определять именованые константы. Можно создавать текстовые и числовые, смешанные.

```typescript
enum Direction {
  Up,
  Down,
  Left,
  Right
}
```

[Подробнее в ответе на вопрос 4](#Что-такое-Enum-и-во-что-он-компилируется).

- `Unknown`

Тип используется, когда переменной может быть присвоено значение любого типа. Однако, хотя
всё что угодно может быть присвоено `unknown`, но `unknown` не может быть присвоен ничему:

```typescript
let varUnknown: unknown = 20;

let str: string = varUnknown;//Type 'unknown' is not assignable to type 'string'
```

- `Any`

Тип, похожий на `unknown`, но имеет отличие: переменную с таким типом можно присваивать другим типам.
Можно даже попытаться прочитать свойство, которое даже не существует (такого с `unknown` не сделаешь):

```typescript
let varAny: any = 20;
let str: string = varAny;//ошибки не будет, всё ок.

varAny.method();//по-прежнему никакой ошибки
```

- `Void`

Буквально означает отсутсвие какого-либо типа. В основном используется в функциях, которые не возвращают никакого значения:

```typescript
function warnUser(): void {
  console.log("This is my warning message");
}
```
Также используется как тип переменной со значением `undefined`:

```typescript
const x: void = undefined;
```

- `Null` и `Undefined`
Принимают соответствующие значения null и undefined. Но фактически мы можем присваивать значения
`null` и `undefined` переменным других типов.
- `Never`
Представляет отсутствие значения и используется в качестве возвращаемого типа функций, которые генерируют или возвращают ошибку.
- `Object`

3. ### Что такое Interface и во что он компилируется
***Interface (Интерфейс)*** можно определить как некоторую договорённость, контракт, которому должны следовать сущности в коде.
Этот "контракт" устанавливает, ***что*** должно быть сделано, но не ***как***. При этом хоть и обязательно, чтобы сущности следовали установленным
договорённостям, однако они могут добавлять и свои.
Интерфейсы можно использовать, чтобы определить структуру функций:
```typescript
interface Order {
  (customerId: number, modelId: number): boolean
}

let orderFn: Order = function (customerId, modelId) {
  //действия для обработки заказа
  return true
}
```
Также интерфейсы очень полезны, чтобы определить, что же должно присутствовать в том или ином классе:

```typescript
interface Car {
  width: number;
  length: number;
  wheelbase: number;
  seatingCapacity: number;
  getTyrePressure?: () => number;
  getRemCharging: () => number;
}

class CarModelPrototype implements Car {
  length: number;
  width: number;
  wheelbase: number;
  seatingCapacity: number;
  doorsRealisation: string;

  constructor(length: number, width: number, wheelbase: number, seatingCapacity: number) {
    this.length = length;
    this.width = width;
    this.wheelbase = wheelbase;
    this.seatingCapacity = seatingCapacity;
  }

  getTyrePressure(): number {
    return 20;//получено путём долгих вычислений
  }

  getRemCharging(): number {
    return 20;//получено путём долгих вычислений
  }
}
```
Сам по себе интерфейс ни во что не компилируется.
Ссылка на статью, где приводятся аналогии с реальной жизнью: https://blog.logrocket.com/interfaces-in-typescript-what-are-they-and-how-do-we-use-them-befbc69b38b3/

4. ### Что такое Enum и во что он компилируется

***Enum (Перечисление)*** - это тип данных в TS, который позволяет определять набор именованых числовых констант. перечисление
состоит из нуля или более элементов, каждый из которых имеет ассоциированное с ним значение. Перечисления бывают числовыми (numeric enums),
строчными (string-based enums), смешанными (heterogeneous enums).

Примеры числового:

```typescript
enum NoYes {
  No,
  Yes,
}

enum NoYes {
  No = 0,
  Yes = 1,
}
```
К слову, перечисление с примера выше компилируется в следующее:

```javascript
"use strict";
var NoYes;
(function (NoYes) {
  NoYes[NoYes["No"] = 0] = "No";
  NoYes[NoYes["Yes"] = 1] = "Yes";
})(NoYes || (NoYes = {}));
```
или же:

```typescript
var NoYes = {
  0: "No",
  1: "Yes",
  "No": 0,
  "Yes": 1,
}
```
Также, если мы присвоим какой-то из констант присвоить число, то следующей константе будет присвоено значение на один больше и т.д.

```typescript
enum AcceptedNumber {
  First = 5,
  Second,
  Third,
}

let secondNumber: AcceptedNumber = AcceptedNumber.Second;
let thirdNumber: AcceptedNumber = AcceptedNumber.Third;

console.log(secondNumber);//6
console.log(thirdNumber);//7
```
Пример строчного:

```typescript
enum PrintMedia {
  Newspaper = "NEWSPAPER",
  Newsletter = "NEWSLETTER",
  Magazine = "MAGAZINE",
  Book = "BOOK",
}
```
Пример смешанного:
```typescript
enum Status {
  Active = "Active",
  Deactivate = 1,
  Pending
}
```
5. ### Что такое геттеры и сеттеры в TypeScript?
***Геттеры и сеттеры*** - это методы класса (с ключевыми словами `get` и `set`), которые позволяют перехватить доступ к свойствам объектов. Они позволяют
более тщательно контролировать доступ к свойствам объекта.
```typescript
class WashingMachine {
  constructor(readonly name: string, private _amountOfPowderInMl: number) {}

  get amountOfPowderInMl(): number {
    return this._amountOfPowderInMl;
  }

  set amountOfPowderInMl(newAmount: number) {
    if (newAmount > 250) {
      console.log("Too much powder!");
    } else {
      this._amountOfPowderInMl = newAmount;
    }
  }
}

let washingMachine = new WashingMachine("Machine1000", 0);

washingMachine.amountOfPowderInMl = 300;//Too much powder!
console.log(washingMachine.amountOfPowderInMl);//0, свойство не назначилось, так как не прошло проверку.

washingMachine.amountOfPowderInMl = 200;
console.log(washingMachine.amountOfPowderInMl);//200
```
6. ### Generics (Обощенные типы)
***Generics (обобщенные типы, "дженерики")*** - это возможность создавать компоненты (функции, классы, интерфейсы), работающие не только с одним,
а с несколькими типами данных. С помощью дженериков можно создавать обобщённые функции, классы и интерфейсы.
Пример с обобщённой функцией:

```typescript
function print<T>(arg: T): T {
  return arg;
}

print("str");//str
print(42);//42
```
Например, в классе:

```typescript
class User<T, U> {
  name: T;
  age: U;

  constructor(name: T, age: U) {
    this.name = name;
    this.age = age;
  }

  print(): void {
    console.log(`Hello ${this.name}, you are ${this.age} years old!`);
  }
}

const newUser1 = new User("Leonardo", 23);
newUser1.print(); // Hello Leonardo, you are 23 years old!

const newUser2 = new User("Leonardo", "23");//если для age был бы указан тип number, то была бы ошибка.
newUser2.print();//Hello Leonardo, you are 23 years old!
```
Без generics на предпоследней строке была бы ошибка. Ведь если для `age` был бы указан тип
`number`, то при передаче строки в качестве второго аргумента появится ошибка "Argument of type 'string' is not assignable
to parameter of type 'number'".

Пример с интерфейсом:

```typescript
interface User {
  firstName: string;
}

interface Client {
  firstName: string;
  lastName: string;
}

interface Admin<T> {
  values: T;
  isAdmin: true;
}

const user: Admin<User> = {
  values: {
    firstName: "Leonardo"
  },
  isAdmin: true
};

const client: Admin<Client> = {
  values: {
    firstName: "Leonardo",
    lastName: "Maldonado"
  },
  isAdmin: true
};
```
Отличие **generics** от использования `any` в примерах выше в том, что не теряется проверка типов, просто типы можно использовать любые.
При использовании `any`, например, в функции, мы не можем быть уверены в том, что, приняв в качестве аргумента строку, функция
строку и вернёт, а если примет число, то число и вернёт. При использовании же generics - да.

Ссылка на понятную статью: https://blog.logrocket.com/getting-started-with-typescript-generics/

7. ### Как сделать так, чтобы классы, объявленные в модуле, были бы доступны и за пределами этого модуля?
При помощи ключевого слова `export`.

```typescript
module Vehicle {
  export class Car {
    constructor (public make: string, public model: string) { }
  }

  let audiCar = new Car("Audi", "Q7");
}

let fordCar = new Vehicle.Car("Ford", "Figo");
```
8. ### Поддерживает ли TypeScript перегрузку функций?

Да, TS поддерживает возможность перегрузки функций. "Перегрузить функцию" означает определить несколько
"версий" функции, которые будут иметь одно и то же имя, но разные типы параметров или разное количество параметров

```typescript
function add(x: string, y: string): string;
function add(x: number, y: number): number;
function add(x: any, y: any): any {
  return x + y;
}

let result1 = add(5, 4);
console.log(result1);// 9

let result2 = add("5", "4");
console.log(result2);// 54

//а вот так не сработает и выдаст ошибку:
let result3 = add(true, false);
console.log(result3);//no overload match this call
```
9. ### Как в TypeScript перегрузить конструктор класса?
- При помощи необязательного параметра:

```typescript
class Box {
  public x: number;
  public y: number;
  public height: number;
  public width: number;

  constructor();
  constructor(obj: IBox);
  constructor(obj?: any) {
    this.x = obj?.x|| 0;
    this.y = obj?.y || 0;
    this.height = obj?.height || 0;
    this.width = obj?.width || 0;
  }   
}
```
- При помощи типа-объединения:

```typescript
class foo {
  private _name: any;

  constructor(name: string | number) {
    this._name = name;
  }
}

let f1 = new foo("bar");
let f2 = new foo(1);
```
10. ### Разница между interface и type в TypeScript?

Разница между `interface` и `type` в том, что:  
- Интерфейсы позволяют выразить пересечение типов, однако не позволяют выразить объединение.
Пример ограничения на типах, которое невозможно на интерфейсах:

```typescript
type Wish =
  | { fast: true, quality: true, cheap: false } // Дорого
  | { fast: true, quality: false, cheap: true } // Некачественно
  | { fast: false, quality: true, cheap: true } // Медленно

const wish: Wish = { fast: true, quality: true, cheap: true } // Не компилируется
```
- Интерфейсы нельзя комбинировать с mapped типами (Partial, Required, Pick):

```typescript
// С типом работает
type RealProfile = Pick<TwitterProfile, 'drinkCoffee'>;

// С интерфейсом не работает
interface RealProfile extends Pick<TwitterProfile, 'drinkCoffee'> {}
```
- Интерфейсы поддерживают declaration merging - то есть слияние интерфейсов с одинаковыми именами:

```typescript
interface Employee {
  salary: number;
}

interface Employee {
  age: number;
}

const employee: Employee = { age: 23 };//Property 'salary' is missing in type '{age: number}', but required in type Employee
```
С `type` такого не происходит:
```typescript
type Employee = {//Duplicate identifier 'Employee'
  salary: number;
}

type Employee = {//Duplicate identifier 'Employee'
  age: number;
}

const employee: Employee = { age: 23 };//Type '{age: number}' is not assignable to type 'Employee'
```
Ссылка: https://teletype.in/@alteregor/rkPlgmQz8

11. ### Для чего нужен тип «Omit»?
Тип `Omit` нужен для того, чтобы указать свойства, которые должны быть исключены из исходного типа.

```typescript
type InhabitedPlanet = {name: string, age: number, population: number};
type UninhabitedPlanet = Omit<InhabitedPlanet, "population">;

let mercury: UninhabitedPlanet = {
  name: "Mercury",
  age: 4503e9,
};
```
12. ### Для чего нужен тип «Record»?

Тип `Record<Keys, Type>` создаёт тип cо свойствами `Keys` типа `Type`.

Например, следующую запись типа
```typescript
type PropResponse = {
  prop1: string
  prop2: string
  prop3: string
};
```
можно записать короче, используя `Record<Keys, Type`:
```typescript
type PropResponse = Record<'prop1' | 'prop2' | 'prop3', string>;
```
13. ### Когда используется ключевое слово «unknown»?

Когда заранее неизвестно, значение какого типа будет присвоено переменной. Потом тип можно проверить:

```typescript
let person: unknown = 'John';

if (typeof person === string) {
  let name: string = person;
}
```
14. ### Разница между абстрактным классом и интерфейсом typescript
- В интерфейсе все свойства являются по-умолчанию абстрактными, а в абстрактном классе некоторые абстрактные,
а некоторые могут быть полностью реализоваными (этим можно управлять).

Пример с интерфейсом:

```typescript
interface Person {
  name: string;
  display(name: string): void;//можно обозначить только, что этот метод должен присутствовать, но нельзя указать как именно он должен быть реализован.
}

class Employee implements Person {//class 'Employee' incorrectly implements interface 'Person'. Property 'display' is missing in type 'Employee' but required in type 'Person'
  name: string;
}
```
Пример с абстрактным классом:

```typescript
abstract class Person {
  abstract name: string;

  display(): void {
    console.log(this.name)//нужно указать реализацию метода
  }
}

class Employee extends Person {//никакой ошибки не будет, метод display необязательный
  name: string;
}
```
- Интерфейсы поддерживают множественно наследование, а абстрактные классы нет.
Множественное наследование - это наследование от более чем одного родителя.

Пример с интерфейсом:

```typescript
interface IPerson {
  name: string;
}

interface IHuman {
  gender: string;
}

interface IAdult extends IPerson {
  empCode: number;
}

interface IAdult extends IHuman {
  hairColor: string
}

let empObj: IEmployee = {//всё ок, никакой ошибки
  empCode: 1,
  name: "Bill",
  gender: "Male",
  hairColor: "dark",
}
```
Пример с абстрактным классом:
```typescript
abstract class Person {
  name: string;
}

abstract class Human {
  gender: string;
}

abstract class Adult extends Person {//Duplicate identifier 'Adult'
  name: string;
  empCode: number;
}

abstract class Adult extends Human {//Duplicate identifier 'Adult'
  hairColor: string;
  gender: string;
}
```
- Интерфейс сам по себе ни во что не компилируется, абстрактный класс же компилируется в JS.
15. ### Когда нужно использовать ключевое слово «declare»?
Ключевое свойство "declare" нужно использовать при использовании библиотеки JS, не объявленной в TS-проекте:

```typescript
declare const libraryName;
```
16. ### Как сделать все свойства интерфейса необязательными?
- При помощи `?` в конце названия свойства (например, `title?: `, `description?: `).

Например:
```typescript
interface Todo {
  title?: string;
  description?: string;
}

const todo: Todo = {
  title: "organize desk",
};//это не вызовет ошибки, потому что свойства необязательные:
```

- При помощи `Partial<Type>`:

```typescript
interface Todo {
  title: string;
  description: string;
}

const todo: Partial<Todo> = {};//ошибки никакой не будет, потому что все поля интерфейса необязательные
```

а также:

```typescript
interface Todo {
  title: string;
  description: string;
}

type Part<T> = {
  [P in keyof T]?: T[P];
};

type PartialTodo = Part<Todo>;

const todo: PartialTodo = {};
```
17. ### Использовании декораторов свойств в TypeScript
Декоратор свойства позволяет добавить ему дополнительное свойство:

```typescript
function format(target: any, propertyKey: string) {
  let _val = target[propertyKey];// получаем значение свойства

  // геттер
  let getter = function() {
    return 'Mr./Ms.' + _val;
  };

  // сеттер
  let setter = function(newVal: string) {
    _val = newVal;
  };

  // удаляем свойство
  if (delete target[propertyKey]) {
    // И создаем новое свойство с геттером и сеттером
    Object.defineProperty(target, propertyKey, {
      get: getter,
      set: setter,
    })
  }
}

class User {
  @format
  name: string;

  constructor(name: string) {
    this.name = name;
  }

  print(): void {
    console.log(this.name);
  }
}

let tom = new User('Tom');

tom.print();//Mr./Mr.Tom
tom.name = 'Tommy';
tom.print();//Mr./Mr.Tommy
```

18. ### Что такое «.map» файл, как и зачем его использовать?

Файл ".map" - это файл карты исходников, который можно использовать при выполнении
отладки. Его можно сгенерировать, установив опцию компилятора *sourseMap* в true в файле tsconfig.json

## Angular
1. ### Метаданные компонента и какие из них обязательные

Метаданные - это то, что предоставляет дополнительные данные о классе для Angular.
Метаданные определяются декоратором (функция, которая добавляет метаданные в класс).
Метаданых существует достаточно много. Некоторые из них:
- `selector` (CSS-селектор, который определяет компонент в шаблоне)
- `changeDetection` (указывает на стратегию отслеживания именений для компонента))
- `templateUrl` (путь к файлу шаблона для этого компонента)
- `template` (инлайновый шаблон)
- `styleUrls` (путь/пути к файлам стилей для этого компонента)
- `styles` (инлайновые стили)
- `encapsulation` (правило инкапсуляции для шаблона и стилей)

Обязательными являются `selector` и `template`/`templateUrl`.

Ссылка: https://angular.io/api/core/Component

2. ### Хуки компонента
***Lifecycle hooks*** - это методы жизненного цикла компонента (Component Lifecycle), которые
описывают каждый из этапов цикла.
Существует 8 методов жизненного цикла компонента:

- OnChanges

Метод ngOnChanges( ) вызывается при изменении входных свойств компонента. Метод в качестве параметра принимает объект-экземпляр класса Simple Changes, в котором ключами являются имена входных свойств, значения которых поменялись. Значениями этих ключей являются объекты со свойтсвами `previousValue` и `currentValue`.

```typescript
import { Component, Input, SimpleChanges } from '@angular/core';

@Component({
  selector: 'app-child',
  template:`{{childAge}}`,
})
export class ChildComponent {
  @Input() childAge: number;

  ngOnChanges(changes: SimpleChanges) {
    console.log(changes);
  }
}
```
```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-parent',
  template: `
    <app-child [childAge]="age"></app-child>
    <input [(ngModel)]="age">
  `,
})
export class ParentComponent {
  age: number = 21;
}
```
![alt text](ngOnChanges1.png "При первом вызове")
![alt text](ngOnChanges2.png "При изменении входного значения")

- OnInit

Метод ngOnInit() вызывается только один раз. Используется для инициализации свойств компонента.
[Пример использования был дан в ответе на вопрос 19.](#Любые-способы-передать-данные-между-двумя-компонентами,-даже-самые-нелепые)

- DoCheck

Метод вызывается каждый раз при запуске механизма отслеживания изменений и один раз после ngOnInit().
[Пример исаользования был дан при ответе на вопрос 15.](#Виды-pipe)

- AfterContentInit

Метод вызывается один раз сразу после первого вызова ngDoCheck() и означает, что в шаблоне был инициализирован контент. [Пример использования дан в ответе на вопрос 4.](#Разница-между-ViewChild-и-ContentChild)

- AfterContentChecked

Вызов метода ngAfterContentChecked() происходит сразу после вызова ngAfterContentInit(). Далее метод вызывается при каждом запуске отслеживания изменений относительно *контента*.

- AfterViewInit

Вызывается один раз после первого вызова ngAfterContentChecked() и означает инициализацию визуальной части компонента, включая его дочерние компоненты. Используется для получения значений переменых, обёрнутых @ViewChild()/@ViewChildren().
[Пример использования дан в ответе на вопрос 4.](#Разница-между-ViewChild-и-ContentChild)   
- AfterViewChecked

Метод ngAfterViewChecked() вызывается сразу после ngAfterViewInit(). Далее - при каждом запуске отслеживания изменений относительно *визуальной части компонента*.

- OnDestroy

Метод ngOnDestroy() вызывается непосредственно перед удалением компонента из DOM. Используется для освобождения ресурсов.

Ссылка: https://webdraftt.com/tutorial/component-lifecycle

3. ### Как написать структурную директиву

Пример структурной директивы (пояснения ниже):
```typescript
//директива-противоположность *ngIf
import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';

@Directive({
  selector: '[appUnless]'
})
export class UnlessDirective {
  @Input() set appUnless(condition: boolean) {
    condition ? this.vcRef.clear() : this.vcRef.createEmbeddedView(this.templateRef);
  }

  constructor(
    private templateRef: TemplateRef<any>,
    private vcRef: ViewContainerRef
  )  { }
}
```
```HTML
<div *appUnless="false">
  Show it or hide it
</div>
```

Что эквивалентно:

```HTML
<ng-template [appUnless]="false">
  <div>
    Show it or hide it
  </div>
</ng-template>
```

В примере структурной директивы:
- `@Input set` позволяет получить извне значения (в данном случае `true`/`false`)
- *TemplateRef* - объект, через который получаем доступ к шаблону директивы `<ng-template>`
- *ViewContainerRef* - объект рендерера. Место, где контент будет отображён
- метод clear() удаляет элемент (в нашем случае `<div>`)
- метод createEmbeddedView() производит рендеринг шаблона  

Ссылка: https://metanit.com/web/angular2/3.6.php
4. ### Разница между ViewChild и ContentChild

И `@ViewChild`, и `@ContentChild` являются декораторами свойств для доступа к дочерним элементам. Однако,
`@ContentChild` имеет доступ к дочерним элементам внутри `<ng-content></ng-content>`.

Например, дочерний элемент:

```typescript
import { Component, Input } from '@angular/core';

@Component({
  selector: 'child',
  template: `
    <div>{{message}}</div>
  `
})

export class ChildComponent {
  @Input() message: string;
}
```

родительский элемент:

```typescript
import {Component, ContentChild, ViewChild} from '@angular/core';

import { ChildComponent } from "../child/child.component";

@Component({
  selector: 'parent',
  template: `
    <child [message]="title"></child>
    <ng-content></ng-content>
    <child [message]="title"></child>
  `,
})

export class ParentComponent {
  title = "Hello, Child!";

  @ContentChild(ChildComponent) firstContentChild: ChildComponent;
  @ViewChild(ChildComponent) firstViewChild: ChildComponent;

  ngAfterContentInit() {
    this.firstContentChild.message = "Hello, First Content Child!";
  }

  ngAfterViewInit() {
    this.firstViewChild.message = "Hello, First View Child!";
  }
}
```

в app.component.html:

```typescript
<parent>
  <child [message]="title"></child>
</parent>
```

И результатом будет:

-Hello, First View Child!
-Hello, First Content Child!
-Hello, Child!

5. ### ngContent, ngContainer, ngTemplate
`<ng-template>` - это шаблонный элемент, который используется со структурными директивами.
Элемент, к которому применяется структурная директива, оборачивается в `<ng-template>`.
`<ng-container>` - это группирующий элемент, который используется, чтобы избежать очень большой вложенности
тегов при использовании структурных директив.
`ng-content` - это элемент, который позволяет родительским элементам внедрять html в дочерние элементы.
Статья: https://www.freecodecamp.org/news/everything-you-need-to-know-about-ng-template-ng-content-ng-container-and-ngtemplateoutlet-4b7b51223691/
6. ### hostListener и hostBinding
`@HostListener` - это декоратор, который позволяет реагировать на DOM - событие, произошедшее на элементе, из директивы.
`@HostBinding` - это декоратор, который позволяет устанавливать свойства элемента через директиву.

Пример с `@HostListener`:

`typescript
//директива, которая меняет цвет элемента при наведении мыши:
import { Directive, ElementRef, Renderer2, HostListener } from '@angular/core';

@Directive({
  selector: '[appChangeColor]',
})

export class ChangeColorDirective {
  constructor(private el: ElementRef, private renderer: Renderer2) {}

   @HostListener("mouseover") onMouseOver() {
       this.ChangeColor("red");
   }
   @HostListener("mouseleave") onMouseLeave() {
     this.ChangeColor("black");
   }

   ChangeColor(color: string) {
     this.renderer.setStyle(this.el.nativeElement, 'color', color);
   }
}
`

`HTML
//app.component.html
<h2 appChangeColor>{{title}}</h2>
`

Если в примере выше также использовать `@HostBinding`, то всё можно переписать так:

`typescript
import { Directive, HostListener, HostBinding } from '@angular/core';

@Directive({
  selector: '[appChangeColor]',
})

export class ChangeColorDirective {
  @HostBinding('style.color') color: string;

  @HostListener("mouseover") onMouseOver() {
       this.color = "red";
   }

   @HostListener("mouseleave") onMouseLeave() {
     this.color = "black";
   }
}
`
Ссылка: https://dzone.com/articles/what-are-hostbinding-and-hostlistener-in-angular
7. ### change detection
***ChangeDetection*** - механизм отслеживания изменений, который отвечает за своевременное отображение в шаблоне
данных при их изменении. Обычно запускается при возникновении событий, выполнении HTTP-запросов или вызове `setTimeout()` и `setInterval()`.

Работает по одной из двух стратегий:
- Default (запуск при любом действии пользователя или изменения состоянии компонента)
Default не всегда есть удобной, ибо если изменяется компонент, то затрагиваются и дочерние.
Например:

```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-parent',
  template: `
    <child></child>
    <input [(ngModel)]="title">
  `,
  styleUrls: ['./parent.component.css'],
})
export class ParentComponent {
  title: string;
}
```
```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'child',
  template: `{{child()}}`
})

export class ChildComponent {
  child() {
    console.log("child");
    return "child"
  }
}

```
![alt text](default1.png "При запуске")
![alt text](default2.png "При нажатии клавиши").

Как видим, выявление изменения в родителе повлияло на дочерний элемент.
- OnPush (запускается в момент вызова стадии жизненного цикла компонента OnChanges и при любом изменении значения используемых в шаблоне объектов Observable).

```typescript
//добавим в child changeDetection: ChangeDetectionStrategy.OnPush
import { Component, ChangeDetectionStrategy } from '@angular/core';

@Component({
  selector: 'child',
  template: `{{child()}}`,
  changeDetection: ChangeDetectionStrategy.OnPush,
})

export class ChildComponent {
  child() {
    console.log("child");
    return "child"
  }
}
```
![alt text](default2.png "При нажатии клавиши при OnPush").

Вторая стратегия используется для повышения эффективности работы приложения (потому что снижается количество вызовов
механизмов отслеживания изменений).

Также существует ChangeDetectionRef
Ссылка: https://webdraftt.com/tutorial/angular-change-detection

8. ### dependency injection
***Dependency Injection (DI)*** - это паттерн программирования, одна из реализаций принципа *Inversion of Control (IoC)*, то есть написания слабо связанного кода. Суть IoC в том, что каждый компонент должен быть как можно более изолированный от других и не должен полагаться в своей работе на детали реализации других компонентов.
Без DI нужно было бы, например, самостоятельно создавать инстансы классов, от которых зависит другой класс. Однако, если бы, например, менялись параметры конструктора этих классов, то эти изменения повлекли бы переделывание кода класса, который зависит от этих других классов. Это делает код трудно поддерживаемым, не переиспользуемым и плохо тестируемым. При использовании DI, создание инстансов выносится за пределы зависимого класса. Зависимый класс при этом просто запрашивает нужные зависимости, понятия не имея, что нужно для их создания и т.д.

Пример DI в Angular:

```typescript
//в logger.service.ts
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class LoggerService {

  constructor() { }

  info(msg: string) {
    console.log(msg);
  }
}
```
```typescript
//в app.component.ts
import { Component } from '@angular/core';
import { LoggerService } from "./logger.service";

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  constructor(loggerService: LoggerService) {//не создаём, а запрашиваем
    loggerService.info('Hello!');
  }
}
```
9. ### Как заинжектить переменную

```typescript
//в app.module.ts
@NgModule({
  providers: [
      {provide: 'someVariable', useValue: 500 }
    ],
})
```
```typescript
//и потом в каком-то компоненте
import { Component, OnInit, Inject } from '@angular/core';

@Component({...})
export class AppComponent implements OnInit {
  constructor(@Inject('someVariable') private someVar: number) {}

  ngOnInit() {
    console.log(this.someVar);
  }
}
```

Ссылка: https://medium.com/coding-blocks/power-of-angular-dependency-injection-b981faa9c0de
10. ### Разница между объявлениями сервиса в компоненте или модуле
Объявление сервиса в компоненте означает, что сервис очень тесно связан именно с этим компонентом
и не будет использоваться где-либо ещё в приложении.
Объявление же сервиса в модуле означает, что во всем приложении будет один инстанс сервиса, и он может быть использован где-угодно.
Ссылка: https://www.pluralsight.com/guides/registering-a-service-with-an-angular-module-or-component
11. ### Виды форм
Формы в Angular бывают двух видов: **reactive** и **template-driven**.

Пример reactive:

`typescript
import { Component } from '@angular/core';
import { FormControl } from '@angular/forms';

@Component({
  selector: 'app-reactive-favourite-color',
  template: `
    Favourite color: <input type="text" [formControl]="favouriteColorControl">
  `
})

export class FavouriteColorComponent {
  favouriteColorControl = new FormControl('');
}
`
Пример template-driven:

`typescript
import { Component } from "@angular/core"

@Component({
  selector: 'app-template-favourite-color',
  template: `
    Favourite color: <input type="text" [(ngModel)]="favouriteColor">
  `
})

export class FavouriteColorComponent {
  favouriteColor = " "
}

`
12. ### Что такое router-outlet
RouterOutlet - это директива, которая используется как компонент `<router-outlet>`. Местоположение
этого компонента в шаблоне указывает на местоположение, где должны быть отображены компоненты при роутинге.
13. ### Как создать дочерний маршрут

Чтобы создать дочерний маршрут нужно:
- В шаблоне компонента, для которого создаются дочерние маршруты нужно добавить компонент `<router-outlet>`, где будут
отображаться компоненты.
- В *AppRoutingModule* в массиве routes в объекте, где указан путь к нужному клмпоненту, добавить поле children, которое также является масивом объектов, в каждом из которых также есть поля `path` и `component`.
Ссылка: https://angular.io/guide/router#nesting-routes
14. ### Виды guard

***Guards*** бывают следующими:
- CanActivate
- CanActiveChild
- CanDeactivate
- Resolve
- CanLoad

Пример использования простого guard:

```typescript
//Guard, который пускает/не пускает на маршрут:
import { Injectable } from '@angular/core';
import { CanActivate } from '@angular/router';

@Injectable({
  providedIn: 'root'
})
export class AdminGuardGuard implements CanActivate {
  canActivate(): boolean {
      //Authentication and Authorization Code here
    return false;
  }
}
```

В *app-routing.module.ts* прописываем следующее:

```typescript
//при добавлени /admin, должно показывать AdminHomeComponent:
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { AdminHomeComponent } from "./admin-home/admin-home.component";
import { AdminGuardGuard } from "./admin-guard.guard";

const routes: Routes = [
  { path: 'admin', component: AdminHomeComponent, canActivate: [AdminGuardGuard]  }
];

@NgModule({
  declarations: [],
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
```
```HTML
<h2>Main Page</h2>
<router-outlet></router-outlet>
```
Поскольку guard возвращает false, то при попытке доступа к AdminHomeComponent через /admin, будет видно только **Main Page**.
Если же поменять возращаемое значение guard на true, то попытка получения доступа к AdminHomeComponent будет удачной.

Ссылка: https://www.youtube.com/watch?v=VRf21fum3nk
15. ### Виды pipe
***Pipes*** бывают двух видов: pure (чистые) и impure (грязные, нечистые).

Разница между чистыми и нечистыми pipes в том, что первые отслеживают изменения в непримитивах только тогда, когда меняется сама ссылка, а не значение по ссылке; вторые же отслеживают все изменения.

Например:

```typescript
//создаём pipe, которая превращает массив в строку
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'formatArray',
})
export class FormatArrayPipe implements PipeTransform {
  transform(array: any): string {
    return array.join(", ");
  }
}
```  
```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'child',
  template: `
    <input #user name="user" class="form-control">
    <button class="btn" (click)="users.push(user.value)">Add</button>
    <p>{{users | formatArray}}</p>
  `,
})

export class ChildComponent {
  users = ["Alice", "Bob", "Clara"];

  ngDoCheck() {
    console.log(this.users);
  }
}
```
Поскольку изначально все pipes являются pure, то будет происходить следующее:
![alt text](PurePipe.png "При использовании Pure pipe")
Как можно увидеть, новый элемент добавился в массив, но это никак не отобразилось, потому что для этого следует
pipe сделать нечистой:

```typescript
@Pipe({
  name: 'formatArray',
  pure: false,//добавить эту строчку
})
```
И тогда всё будет работаь как надо:
![alt text](ImpurePipe.png "При использовании Impure pipe")
Ссылка: https://metanit.com/web/angular2/8.3.php
16. ### Для чего используется zone.js
Zone.js используется, чтобы сделать возможным change detection. Можно отключить. Для этого нужно в файле **main.ts** сделать следующее:

```typescript
platformBrowserDynamic().bootstrapModule(AppModule, {ngZone: "noop"})
  .catch(err => console.error(err));
```
https://www.youtube.com/watch?v=wQCiE8040gg
17. ### Tasks в zone.js
В zone.js существуют следующие виды тасков:
- Microtask

Выполняется сразу после какой-то текущей задачи. Нельзя отменить, поэтому точно сработает один раз.
- Macrotask

Можно запланировать. Можно отменять. Также, выполняется после какой-то задержки.
- EventTask

"Слушает" какое-то будущее событие. Какая задержка будет перед выполнением - непонятно, может не произойи ни разу, а может
много раз.

https://github.com/angular/zone.js/blob/master/dist/zone.js.d.ts
18. ### Как протестировать асинхронный код
При помощи `fakeAsync`, а также `flush`, `tick`, `flushMicrotasks`.

Например, есть такой асинхронный код в сервисе:
```typescript
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class SumService {
  sumAsync(a: number, b: number): Promise<number> {
    return new Promise(resolve => {
      setTimeout(() => {
        resolve(a + b);
      }, 2000);
    });
  }
}
```

Для его тестирования нужно написать следующий тест (при условии наличия автоматически сгенерированной заготовки):

```typescript
//sum.services.ts
it('should return sum async', fakeAsync(() => {
  service.sumAsync(4, 5).then(result => {
  expect(result).toBe(9);
});

flush();
}));
```

либо же:

```typescript
it('should return sum async', fakeAsync(() => {
  service.sumAsync(4, 5).then(result => {
  expect(result).toBe(9);
});

tick(2000);
}));
```
`flushMicrotasks` в данном случае не сработает, потому что setTimeout относится к макротаскам, а не микротаскам.

Ссылка: https://www.youtube.com/watch?v=4evLVxAt1xU

19. ### Любые способы передать данные между двумя компонентами, даже самые нелепые
- при помощи `@Input`:

```typescript
//компонент, КУДА данные передаются
import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-child',
  template:`Name: {{name}}`,
})
export class ChildComponent {
  @Input() name: string;
}
```
```typescript
//компонент, ОТКУДА данные передаются
import { Component } from '@angular/core';

@Component({
  selector: 'app-parent',
  template: `<app-child [name]="name"></app-child>`,
})
export class ParentComponent {
  name: string = "Victoria";
}
```
- При помощи @Output и EventEmitter:

```typescript
//компонент, ОТКУДА данные передаются
import { Component, Output, EventEmitter} from '@angular/core';

@Component({
  selector: 'app-child',
  template:`<div (click)="sendName.emit('Victoria')">Click to get name</div>`,
})
export class ChildComponent {
  @Output() sendName = new EventEmitter();
}
```
```typescript
//компонент, КУДА данные передаются
import { Component } from '@angular/core';

@Component({
  selector: 'app-parent',
  template: `
    <app-child (sendName)="getName($event)"></app-child>
    <p>Hi! My name is {{name}}</p>
  `,
})
export class ParentComponent {
  name: string;
  getName(name: string) {
    this.name = name;
  }
}
```
- При помощи сервиса:

```typescript
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class ServiceService {
  someData: number = 30;
}
```
```typescript
import { Component, OnInit } from '@angular/core';
import { ServiceService } from '../service.service';

@Component({
  selector: 'app-parent',
  template: `
    <app-child></app-child>
    <p>{{parentAge}}</p>
  `,
})
export class ParentComponent implements OnInit{
  parentAge: number;

  constructor(private service: ServiceService) {}

  ngOnInit() {
    this.parentAge = this.service.someData;
    this.service.someData = 10;
  }
}
```
```typescript
import { Component, OnInit } from '@angular/core';
import { ServiceService } from "../service.service";

@Component({
  selector: 'app-child',
  template:`<div>{{childAge}}</div>`,
})
export class ChildComponent implements OnInit {
  childAge: number;

  constructor(private service: ServiceService) {}

  ngOnInit() {
    this.childAge = this.service.someData;
  }
}
```
20. ### Разница между AOT и JIT
При ***AOT (Ahead of Time Compilation)*** компиляция происходит во время сборки (build time).  

При ***JIT (Just in Time Compilation)*** компиляция происходит во время выполнения (run time).
https://www.youtube.com/watch?v=EhnD7qHDerc
